<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>pyfoma.algorithms &#8212; PyFoma 1.0.7 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=5ecbeea2" />
    <link rel="stylesheet" type="text/css" href="../../_static/basic.css?v=b08954a9" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=27fed22d" />
    <script src="../../_static/documentation_options.js?v=46dfa7f5"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for pyfoma.algorithms</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python</span>

<span class="sd">&quot;&quot;&quot;Defines common algorithms over FSTs&quot;&quot;&quot;</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pyfoma.fst</span><span class="w"> </span><span class="kn">import</span> <span class="n">FST</span><span class="p">,</span> <span class="n">State</span><span class="p">,</span> <span class="n">Transition</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pyfoma.private.partition_refinement</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">partition_refinement</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pyfoma.eliminate_flags</span><span class="w"> </span><span class="kn">import</span> <span class="n">eliminate_fst_flags</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">heapq</span><span class="o">,</span><span class="w"> </span><span class="nn">operator</span><span class="o">,</span><span class="w"> </span><span class="nn">itertools</span><span class="o">,</span><span class="w"> </span><span class="nn">functools</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">deque</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Callable</span>


<span class="c1"># region Function Wrappers</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_copy_param</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Automatically uses a copy of the FST parameter instead of the original value, in order to avoid mutating the</span>
<span class="sd">    object. Use on any method that returns a modified version of an FST.&quot;&quot;&quot;</span>
    <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">wrapper_decorator</span><span class="p">(</span><span class="n">fst</span><span class="p">:</span> <span class="s1">&#39;FST&#39;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">fst</span><span class="o">.</span><span class="n">__copy__</span><span class="p">(),</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">wrapper_decorator</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_harmonize_alphabet</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A wrapper for expanding .-symbols when operations of arity 2 are performed.</span>
<span class="sd">       For example, if calculating the union of FSM1 and FSM2, and both contain</span>
<span class="sd">       .-symbols, the transitions with . are expanded to include the symbols that</span>
<span class="sd">       are present in the other FST.&quot;&quot;&quot;</span>
    <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">wrapper_decorator</span><span class="p">(</span><span class="n">fst1</span><span class="p">:</span> <span class="s1">&#39;FST&#39;</span><span class="p">,</span> <span class="n">fst2</span><span class="p">:</span> <span class="s1">&#39;FST&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span> <span class="ow">in</span> <span class="p">[(</span><span class="n">fst1</span><span class="p">,</span> <span class="n">fst2</span><span class="p">),</span> <span class="p">(</span><span class="n">fst2</span><span class="p">,</span> <span class="n">fst1</span><span class="p">)]:</span>
            <span class="k">if</span> <span class="s1">&#39;.&#39;</span> <span class="ow">in</span> <span class="n">A</span><span class="o">.</span><span class="n">alphabet</span> <span class="ow">and</span> <span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">alphabet</span> <span class="o">-</span> <span class="p">{</span><span class="s1">&#39;.&#39;</span><span class="p">})</span> <span class="o">!=</span> <span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">alphabet</span> <span class="o">-</span> <span class="p">{</span><span class="s1">&#39;.&#39;</span><span class="p">}):</span>
                <span class="n">Aexpand</span> <span class="o">=</span> <span class="n">B</span><span class="o">.</span><span class="n">alphabet</span> <span class="o">-</span> <span class="n">A</span><span class="o">.</span><span class="n">alphabet</span> <span class="o">-</span> <span class="p">{</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">}</span>
                <span class="k">if</span> <span class="n">A</span> <span class="o">==</span> <span class="n">fst2</span><span class="p">:</span>
                    <span class="n">A</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">fst2</span><span class="o">.</span><span class="n">copy_filtered</span><span class="p">()</span>
                    <span class="n">fst2</span> <span class="o">=</span> <span class="n">A</span> <span class="c1"># Need to copy to avoid mutating other</span>
                <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">all_transitions</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">states</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="s1">&#39;.&#39;</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">sym</span> <span class="ow">in</span> <span class="n">Aexpand</span><span class="p">:</span>
                            <span class="n">newl</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">lbl</span> <span class="k">if</span> <span class="n">lbl</span> <span class="o">!=</span> <span class="s1">&#39;.&#39;</span> <span class="k">else</span> <span class="n">sym</span> <span class="k">for</span> <span class="n">lbl</span> <span class="ow">in</span> <span class="n">l</span><span class="p">)</span>
                            <span class="n">s</span><span class="o">.</span><span class="n">add_transition</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">targetstate</span><span class="p">,</span> <span class="n">newl</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">weight</span><span class="p">)</span>

        <span class="n">newalphabet</span> <span class="o">=</span> <span class="n">fst1</span><span class="o">.</span><span class="n">alphabet</span> <span class="o">|</span> <span class="n">fst2</span><span class="o">.</span><span class="n">alphabet</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">fst1</span><span class="p">,</span> <span class="n">fst2</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># Do something after</span>
        <span class="n">value</span><span class="o">.</span><span class="n">alphabet</span> <span class="o">=</span> <span class="n">newalphabet</span>
        <span class="k">return</span> <span class="n">value</span>
    <span class="k">return</span> <span class="n">wrapper_decorator</span>

<span class="c1"># endregion</span>

<span class="c1"># region Algorithms</span>


<div class="viewcode-block" id="trimmed">
<a class="viewcode-back" href="../../pyfoma.html#pyfoma.algorithms.trimmed">[docs]</a>
<span class="nd">@_copy_param</span>
<span class="k">def</span><span class="w"> </span><span class="nf">trimmed</span><span class="p">(</span><span class="n">fst</span><span class="p">:</span> <span class="s1">&#39;FST&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;FST&#39;</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns a modified FST, removing states that aren&#39;t both accessible and coaccessible.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">filtered_coaccessible</span><span class="p">(</span><span class="n">filtered_accessible</span><span class="p">(</span><span class="n">fst</span><span class="p">))</span></div>



<div class="viewcode-block" id="filtered_accessible">
<a class="viewcode-back" href="../../pyfoma.html#pyfoma.algorithms.filtered_accessible">[docs]</a>
<span class="nd">@_copy_param</span>
<span class="k">def</span><span class="w"> </span><span class="nf">filtered_accessible</span><span class="p">(</span><span class="n">fst</span><span class="p">:</span> <span class="s1">&#39;FST&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;FST&#39;</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns a modified FST, removing states that are not on a path from the initial state.&quot;&quot;&quot;</span>
    <span class="n">explored</span> <span class="o">=</span> <span class="p">{</span> <span class="n">fst</span><span class="o">.</span><span class="n">initialstate</span> <span class="p">}</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="n">fst</span><span class="o">.</span><span class="n">initialstate</span><span class="p">])</span>
    <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
        <span class="n">source</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">label</span><span class="p">,</span> <span class="n">transition</span> <span class="ow">in</span> <span class="n">source</span><span class="o">.</span><span class="n">all_transitions</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">transition</span><span class="o">.</span><span class="n">targetstate</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">explored</span><span class="p">:</span>
                <span class="n">explored</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">transition</span><span class="o">.</span><span class="n">targetstate</span><span class="p">)</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">transition</span><span class="o">.</span><span class="n">targetstate</span><span class="p">)</span>

    <span class="n">fst</span><span class="o">.</span><span class="n">states</span> <span class="o">=</span> <span class="n">explored</span>
    <span class="n">fst</span><span class="o">.</span><span class="n">finalstates</span> <span class="o">&amp;=</span> <span class="n">fst</span><span class="o">.</span><span class="n">states</span>
    <span class="k">return</span> <span class="n">fst</span></div>



<div class="viewcode-block" id="filtered_coaccessible">
<a class="viewcode-back" href="../../pyfoma.html#pyfoma.algorithms.filtered_coaccessible">[docs]</a>
<span class="nd">@_copy_param</span>
<span class="k">def</span><span class="w"> </span><span class="nf">filtered_coaccessible</span><span class="p">(</span><span class="n">fst</span><span class="p">:</span> <span class="s1">&#39;FST&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;FST&#39;</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns a modified FST, removing states and transitions to states that have no path to a final state.&quot;&quot;&quot;</span>
    <span class="n">explored</span> <span class="o">=</span> <span class="p">{</span><span class="n">fst</span><span class="o">.</span><span class="n">initialstate</span><span class="p">}</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="n">fst</span><span class="o">.</span><span class="n">initialstate</span><span class="p">])</span>
    <span class="n">inverse</span> <span class="o">=</span> <span class="p">{</span><span class="n">s</span><span class="p">:</span> <span class="nb">set</span><span class="p">()</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">fst</span><span class="o">.</span><span class="n">states</span><span class="p">}</span>  <span class="c1"># store all preceding arcs here</span>
    <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
        <span class="n">source</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">source</span><span class="o">.</span><span class="n">all_targets</span><span class="p">():</span>
            <span class="n">inverse</span><span class="p">[</span><span class="n">target</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">target</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">explored</span><span class="p">:</span>
                <span class="n">explored</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>

    <span class="n">stack</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">fst</span><span class="o">.</span><span class="n">finalstates</span><span class="p">])</span>
    <span class="n">coaccessible</span> <span class="o">=</span> <span class="p">{</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">fst</span><span class="o">.</span><span class="n">finalstates</span><span class="p">}</span>
    <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
        <span class="n">source</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">previous</span> <span class="ow">in</span> <span class="n">inverse</span><span class="p">[</span><span class="n">source</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">previous</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">coaccessible</span><span class="p">:</span>
                <span class="n">coaccessible</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">previous</span><span class="p">)</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">previous</span><span class="p">)</span>

    <span class="n">coaccessible</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">fst</span><span class="o">.</span><span class="n">initialstate</span><span class="p">)</span>  <span class="c1"># Let&#39;s make an exception for the initial</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">fst</span><span class="o">.</span><span class="n">states</span><span class="p">:</span>  <span class="c1"># Need to also remove transitions to non-coaccessibles</span>
        <span class="n">s</span><span class="o">.</span><span class="n">remove_transitions_to_targets</span><span class="p">(</span><span class="n">fst</span><span class="o">.</span><span class="n">states</span> <span class="o">-</span> <span class="n">coaccessible</span><span class="p">)</span>

    <span class="n">fst</span><span class="o">.</span><span class="n">states</span> <span class="o">&amp;=</span> <span class="n">coaccessible</span>
    <span class="n">fst</span><span class="o">.</span><span class="n">finalstates</span> <span class="o">&amp;=</span> <span class="n">fst</span><span class="o">.</span><span class="n">states</span>
    <span class="k">return</span> <span class="n">fst</span></div>



<div class="viewcode-block" id="scc">
<a class="viewcode-back" href="../../pyfoma.html#pyfoma.algorithms.scc">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">scc</span><span class="p">(</span><span class="n">fst</span><span class="p">:</span> <span class="s1">&#39;FST&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">set</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the strongly connected components of an FST.</span>

<span class="sd">       This is a basic implementation of Tarjan&#39;s (1972) algorithm.</span>
<span class="sd">       Tarjan, R. E. (1972), &quot;Depth-first search and linear graph algorithms&quot;,</span>
<span class="sd">       SIAM Journal on Computing, 1 (2): 146–160.</span>

<span class="sd">       Returns a set of frozensets of states, one frozenset for each SCC.&quot;&quot;&quot;</span>

    <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([])</span>
    <span class="n">sccs</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">lowlink</span><span class="p">,</span> <span class="n">onstack</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(),</span> <span class="p">{},</span> <span class="p">{},</span> <span class="nb">set</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_strongconnect</span><span class="p">(</span><span class="n">state</span><span class="p">):</span>
        <span class="k">nonlocal</span> <span class="n">index</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">lowlink</span><span class="p">,</span> <span class="n">onstack</span><span class="p">,</span> <span class="n">sccs</span>
        <span class="n">indices</span><span class="p">[</span><span class="n">state</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span>
        <span class="n">lowlink</span><span class="p">[</span><span class="n">state</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span>
        <span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">S</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="n">onstack</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="n">targets</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">all_targets</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">targets</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">target</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
                <span class="n">_strongconnect</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
                <span class="n">lowlink</span><span class="p">[</span><span class="n">state</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">lowlink</span><span class="p">[</span><span class="n">state</span><span class="p">],</span> <span class="n">lowlink</span><span class="p">[</span><span class="n">target</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">onstack</span><span class="p">:</span>
                <span class="n">lowlink</span><span class="p">[</span><span class="n">state</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">lowlink</span><span class="p">[</span><span class="n">state</span><span class="p">],</span> <span class="n">indices</span><span class="p">[</span><span class="n">target</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">lowlink</span><span class="p">[</span><span class="n">state</span><span class="p">]</span> <span class="o">==</span> <span class="n">indices</span><span class="p">[</span><span class="n">state</span><span class="p">]:</span>
            <span class="n">currscc</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">target</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="n">onstack</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
                <span class="n">currscc</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">state</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="n">sccs</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">frozenset</span><span class="p">(</span><span class="n">currscc</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">fst</span><span class="o">.</span><span class="n">states</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">s</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
            <span class="n">_strongconnect</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">sccs</span></div>



<div class="viewcode-block" id="pushed_weights">
<a class="viewcode-back" href="../../pyfoma.html#pyfoma.algorithms.pushed_weights">[docs]</a>
<span class="nd">@_copy_param</span>
<span class="k">def</span><span class="w"> </span><span class="nf">pushed_weights</span><span class="p">(</span><span class="n">fst</span><span class="p">:</span> <span class="s1">&#39;FST&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;FST&#39;</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns a modified FST, pushing weights toward the initial state. Calls dijkstra and maybe scc.&quot;&quot;&quot;</span>
    <span class="n">potentials</span> <span class="o">=</span> <span class="p">{</span><span class="n">s</span><span class="p">:</span><span class="n">dijkstra</span><span class="p">(</span><span class="n">fst</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">fst</span><span class="o">.</span><span class="n">states</span><span class="p">}</span>
    <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">fst</span><span class="o">.</span><span class="n">all_transitions</span><span class="p">(</span><span class="n">fst</span><span class="o">.</span><span class="n">states</span><span class="p">):</span>
        <span class="n">t</span><span class="o">.</span><span class="n">weight</span> <span class="o">+=</span> <span class="n">potentials</span><span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">targetstate</span><span class="p">]</span> <span class="o">-</span> <span class="n">potentials</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">fst</span><span class="o">.</span><span class="n">finalstates</span><span class="p">:</span>
        <span class="n">s</span><span class="o">.</span><span class="n">finalweight</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">finalweight</span> <span class="o">-</span> <span class="n">potentials</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>
    <span class="n">residualweight</span> <span class="o">=</span> <span class="n">potentials</span><span class="p">[</span><span class="n">fst</span><span class="o">.</span><span class="n">initialstate</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">residualweight</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="c1"># Add residual to all exits of initial state SCC and finals in that SCC</span>
        <span class="n">mainscc</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">scc</span><span class="p">(</span><span class="n">fst</span><span class="p">)</span> <span class="k">if</span> <span class="n">fst</span><span class="o">.</span><span class="n">initialstate</span> <span class="ow">in</span> <span class="n">s</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">fst</span><span class="o">.</span><span class="n">all_transitions</span><span class="p">(</span><span class="n">mainscc</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">t</span><span class="o">.</span><span class="n">targetstate</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">mainscc</span><span class="p">:</span> <span class="c1"># We&#39;re exiting the main SCC</span>
                <span class="n">t</span><span class="o">.</span><span class="n">weight</span> <span class="o">+=</span> <span class="n">residualweight</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">mainscc</span> <span class="o">&amp;</span> <span class="n">fst</span><span class="o">.</span><span class="n">finalstates</span><span class="p">:</span> <span class="c1"># Add res w to finals in initial SCC</span>
            <span class="n">s</span><span class="o">.</span><span class="n">finalweight</span> <span class="o">+=</span> <span class="n">residualweight</span>
    <span class="k">return</span> <span class="n">fst</span></div>



<div class="viewcode-block" id="mapped_labels">
<a class="viewcode-back" href="../../pyfoma.html#pyfoma.algorithms.mapped_labels">[docs]</a>
<span class="nd">@_copy_param</span>
<span class="k">def</span><span class="w"> </span><span class="nf">mapped_labels</span><span class="p">(</span><span class="n">fst</span><span class="p">:</span> <span class="s1">&#39;FST&#39;</span><span class="p">,</span> <span class="nb">map</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;FST&#39;</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns a modified FST, relabeling the transducer with new labels from dictionary mapping.</span>

<span class="sd">    Example: ``map_labels(myfst, {&#39;a&#39;:&#39;&#39;, &#39;b&#39;:&#39;a&#39;})``&quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">fst</span><span class="o">.</span><span class="n">states</span><span class="p">:</span>
        <span class="n">newlabelings</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">lbl</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">transitions</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">l</span> <span class="ow">in</span> <span class="n">lbl</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">map</span><span class="p">):</span>
                <span class="n">newlabel</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">[</span><span class="n">lbl</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="k">if</span> <span class="n">lbl</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">in</span> <span class="nb">map</span> <span class="k">else</span> <span class="n">lbl</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lbl</span><span class="p">)))</span>
                <span class="n">newlabelings</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">lbl</span><span class="p">,</span> <span class="n">newlabel</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span> <span class="ow">in</span> <span class="n">newlabelings</span><span class="p">:</span>
            <span class="n">s</span><span class="o">.</span><span class="n">rename_label</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">)</span>
    <span class="n">fst</span><span class="o">.</span><span class="n">alphabet</span> <span class="o">=</span> <span class="n">fst</span><span class="o">.</span><span class="n">alphabet</span> <span class="o">-</span> <span class="nb">map</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="nb">map</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">-</span> <span class="p">{</span><span class="s1">&#39;&#39;</span><span class="p">}</span>
    <span class="k">return</span> <span class="n">fst</span></div>



<div class="viewcode-block" id="epsilon_removed">
<a class="viewcode-back" href="../../pyfoma.html#pyfoma.algorithms.epsilon_removed">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">epsilon_removed</span><span class="p">(</span><span class="n">fst</span><span class="p">:</span> <span class="s1">&#39;FST&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;FST&#39;</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns a modified FST, creating new epsilon-free FSM equivalent to original.&quot;&quot;&quot;</span>
    <span class="c1"># For each state s, figure out the min-cost w&#39; to hop to a state t with epsilons</span>
    <span class="c1"># Then, add the (non-e) transitions of state t to s, adding w&#39; to their cost</span>
    <span class="c1"># Also, if t is final and s is not, make s final with cost t.finalweight ⊗ w&#39;</span>
    <span class="c1"># If s and t are both final, make s&#39;s finalweight s.final ⊕ (t.finalweight ⊗ w&#39;)</span>

    <span class="n">eclosures</span> <span class="o">=</span> <span class="p">{</span><span class="n">s</span><span class="p">:</span><span class="n">epsilon_closure</span><span class="p">(</span><span class="n">fst</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">fst</span><span class="o">.</span><span class="n">states</span><span class="p">}</span>
    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ec</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">ec</span> <span class="ow">in</span> <span class="n">eclosures</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span> <span class="c1"># bail, no epsilon transitions</span>
        <span class="k">return</span> <span class="n">fst</span><span class="o">.</span><span class="n">__copy__</span><span class="p">()</span>
    <span class="n">newfst</span><span class="p">,</span> <span class="n">mapping</span> <span class="o">=</span> <span class="n">fst</span><span class="o">.</span><span class="n">copy_filtered</span><span class="p">(</span><span class="n">labelfilter</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">lbl</span><span class="p">:</span> <span class="nb">any</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sublabel</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">sublabel</span> <span class="ow">in</span> <span class="n">lbl</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">state</span><span class="p">,</span> <span class="n">ec</span> <span class="ow">in</span> <span class="n">eclosures</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">target</span><span class="p">,</span> <span class="n">cost</span> <span class="ow">in</span> <span class="n">ec</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># copy target&#39;s transitions to source</span>
            <span class="k">for</span> <span class="n">label</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">target</span><span class="o">.</span><span class="n">all_transitions</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sublabel</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">sublabel</span> <span class="ow">in</span> <span class="n">label</span><span class="p">):</span> <span class="c1"># is epsilon: skip</span>
                    <span class="k">continue</span>
                <span class="n">mapping</span><span class="p">[</span><span class="n">state</span><span class="p">]</span><span class="o">.</span><span class="n">add_transition</span><span class="p">(</span><span class="n">mapping</span><span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">targetstate</span><span class="p">],</span> <span class="n">label</span><span class="p">,</span> <span class="n">cost</span> <span class="o">+</span> <span class="n">t</span><span class="o">.</span><span class="n">weight</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">fst</span><span class="o">.</span><span class="n">finalstates</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">state</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">fst</span><span class="o">.</span><span class="n">finalstates</span><span class="p">:</span>
                    <span class="n">newfst</span><span class="o">.</span><span class="n">finalstates</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">mapping</span><span class="p">[</span><span class="n">state</span><span class="p">])</span>
                    <span class="n">mapping</span><span class="p">[</span><span class="n">state</span><span class="p">]</span><span class="o">.</span><span class="n">finalweight</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="n">mapping</span><span class="p">[</span><span class="n">state</span><span class="p">]</span><span class="o">.</span><span class="n">finalweight</span> <span class="o">+=</span> <span class="n">cost</span> <span class="o">+</span> <span class="n">target</span><span class="o">.</span><span class="n">finalweight</span>
    <span class="k">return</span> <span class="n">newfst</span></div>



<div class="viewcode-block" id="epsilon_closure">
<a class="viewcode-back" href="../../pyfoma.html#pyfoma.algorithms.epsilon_closure">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">epsilon_closure</span><span class="p">(</span><span class="n">fst</span><span class="p">:</span> <span class="s1">&#39;FST&#39;</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Finds, for a state the set of states reachable by epsilon-hopping.&quot;&quot;&quot;</span>
    <span class="n">explored</span><span class="p">,</span> <span class="n">cntr</span> <span class="o">=</span> <span class="p">{},</span> <span class="n">itertools</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
    <span class="n">q</span> <span class="o">=</span> <span class="p">[(</span><span class="mf">0.0</span><span class="p">,</span> <span class="nb">next</span><span class="p">(</span><span class="n">cntr</span><span class="p">),</span> <span class="n">state</span><span class="p">)]</span>
    <span class="k">while</span> <span class="n">q</span><span class="p">:</span>
        <span class="n">cost</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">source</span> <span class="o">=</span> <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">source</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">explored</span><span class="p">:</span>
            <span class="n">explored</span><span class="p">[</span><span class="n">source</span><span class="p">]</span> <span class="o">=</span> <span class="n">cost</span>
            <span class="k">for</span> <span class="n">target</span><span class="p">,</span> <span class="n">weight</span> <span class="ow">in</span> <span class="n">source</span><span class="o">.</span><span class="n">all_epsilon_targets_cheapest</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="p">(</span><span class="n">cost</span> <span class="o">+</span> <span class="n">weight</span><span class="p">,</span> <span class="nb">next</span><span class="p">(</span><span class="n">cntr</span><span class="p">),</span> <span class="n">target</span><span class="p">))</span>
    <span class="n">explored</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="c1"># Remove the state where we started from</span>
    <span class="k">return</span> <span class="n">explored</span></div>



<div class="viewcode-block" id="dijkstra">
<a class="viewcode-back" href="../../pyfoma.html#pyfoma.algorithms.dijkstra">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">dijkstra</span><span class="p">(</span><span class="n">fst</span><span class="p">:</span> <span class="s1">&#39;FST&#39;</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The cost of the cheapest path from state to a final state. Go Edsger!&quot;&quot;&quot;</span>
    <span class="n">explored</span><span class="p">,</span> <span class="n">cntr</span> <span class="o">=</span> <span class="p">{</span><span class="n">state</span><span class="p">},</span> <span class="n">itertools</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>  <span class="c1"># decrease-key is for wusses</span>
    <span class="n">Q</span> <span class="o">=</span> <span class="p">[(</span><span class="mf">0.0</span><span class="p">,</span> <span class="nb">next</span><span class="p">(</span><span class="n">cntr</span><span class="p">),</span> <span class="n">state</span><span class="p">)]</span> <span class="c1"># Middle is dummy cntr to avoid key ties</span>
    <span class="k">while</span> <span class="n">Q</span><span class="p">:</span>
        <span class="n">w</span><span class="p">,</span> <span class="n">_</span> <span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>       <span class="c1"># First None we pull out is the lowest-cost exit</span>
            <span class="k">return</span> <span class="n">w</span>
        <span class="n">explored</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">fst</span><span class="o">.</span><span class="n">finalstates</span><span class="p">:</span>
            <span class="c1"># now we push a None state to signal the exit from a final</span>
            <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="p">(</span><span class="n">w</span> <span class="o">+</span> <span class="n">s</span><span class="o">.</span><span class="n">finalweight</span><span class="p">,</span> <span class="nb">next</span><span class="p">(</span><span class="n">cntr</span><span class="p">),</span> <span class="kc">None</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">trgt</span><span class="p">,</span> <span class="n">cost</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">all_targets_cheapest</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">trgt</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">explored</span><span class="p">:</span>
                <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="p">(</span><span class="n">cost</span> <span class="o">+</span> <span class="n">w</span><span class="p">,</span> <span class="nb">next</span><span class="p">(</span><span class="n">cntr</span><span class="p">),</span> <span class="n">trgt</span><span class="p">))</span>
    <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="labelled_states_topology">
<a class="viewcode-back" href="../../pyfoma.html#pyfoma.algorithms.labelled_states_topology">[docs]</a>
<span class="nd">@_copy_param</span>
<span class="k">def</span><span class="w"> </span><span class="nf">labelled_states_topology</span><span class="p">(</span><span class="n">fst</span><span class="p">:</span> <span class="s1">&#39;FST&#39;</span><span class="p">,</span> <span class="n">mode</span> <span class="o">=</span> <span class="s1">&#39;BFS&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;FST&#39;</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns a modified FST, topologically sorting and labelling states with numbers.</span>
<span class="sd">    Keyword arguments:</span>
<span class="sd">    mode -- &#39;BFS&#39;, i.e. breadth-first search by default. &#39;DFS&#39; is depth-first.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cntr</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
    <span class="n">Q</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="n">fst</span><span class="o">.</span><span class="n">initialstate</span><span class="p">])</span>
    <span class="n">inqueue</span> <span class="o">=</span> <span class="p">{</span><span class="n">fst</span><span class="o">.</span><span class="n">initialstate</span><span class="p">}</span>
    <span class="k">while</span> <span class="n">Q</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span> <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;BFS&#39;</span> <span class="k">else</span> <span class="n">Q</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">s</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">cntr</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">label</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">all_transitions</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">t</span><span class="o">.</span><span class="n">targetstate</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">inqueue</span><span class="p">:</span>
                <span class="n">Q</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">targetstate</span><span class="p">)</span>
                <span class="n">inqueue</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">targetstate</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">fst</span></div>



<div class="viewcode-block" id="words_nbest">
<a class="viewcode-back" href="../../pyfoma.html#pyfoma.algorithms.words_nbest">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">words_nbest</span><span class="p">(</span><span class="n">fst</span><span class="p">:</span> <span class="s1">&#39;FST&#39;</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Finds the n cheapest word in an FST, returning a list.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">islice</span><span class="p">(</span><span class="n">words_cheapest</span><span class="p">(</span><span class="n">fst</span><span class="p">),</span> <span class="n">n</span><span class="p">))</span></div>



<div class="viewcode-block" id="words_cheapest">
<a class="viewcode-back" href="../../pyfoma.html#pyfoma.algorithms.words_cheapest">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">words_cheapest</span><span class="p">(</span><span class="n">fst</span><span class="p">:</span> <span class="s1">&#39;FST&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A generator to yield all words in order of cost, cheapest first.&quot;&quot;&quot;</span>
    <span class="n">cntr</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
    <span class="n">Q</span> <span class="o">=</span> <span class="p">[(</span><span class="mf">0.0</span><span class="p">,</span> <span class="nb">next</span><span class="p">(</span><span class="n">cntr</span><span class="p">),</span> <span class="n">fst</span><span class="o">.</span><span class="n">initialstate</span><span class="p">,</span> <span class="p">[])]</span>
    <span class="k">while</span> <span class="n">Q</span><span class="p">:</span>
        <span class="n">cost</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">seq</span> <span class="o">=</span> <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">s</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">cost</span><span class="p">,</span> <span class="n">seq</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">fst</span><span class="o">.</span><span class="n">finalstates</span><span class="p">:</span>
                <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="p">(</span><span class="n">cost</span> <span class="o">+</span> <span class="n">s</span><span class="o">.</span><span class="n">finalweight</span><span class="p">,</span> <span class="nb">next</span><span class="p">(</span><span class="n">cntr</span><span class="p">),</span> <span class="kc">None</span><span class="p">,</span> <span class="n">seq</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">label</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">all_transitions</span><span class="p">():</span>
                <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="p">(</span><span class="n">cost</span> <span class="o">+</span> <span class="n">t</span><span class="o">.</span><span class="n">weight</span><span class="p">,</span> <span class="nb">next</span><span class="p">(</span><span class="n">cntr</span><span class="p">),</span> <span class="n">t</span><span class="o">.</span><span class="n">targetstate</span><span class="p">,</span> <span class="n">seq</span> <span class="o">+</span> <span class="p">[</span><span class="n">label</span><span class="p">]))</span></div>



<div class="viewcode-block" id="determinized_unweighted">
<a class="viewcode-back" href="../../pyfoma.html#pyfoma.algorithms.determinized_unweighted">[docs]</a>
<span class="nd">@_copy_param</span>
<span class="k">def</span><span class="w"> </span><span class="nf">determinized_unweighted</span><span class="p">(</span><span class="n">fst</span><span class="p">:</span> <span class="s1">&#39;FST&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;FST&#39;</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns a modified FST, determinized with all zero weights.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">determinized</span><span class="p">(</span><span class="n">fst</span><span class="p">,</span> <span class="n">staterep</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">s</span><span class="p">,</span> <span class="n">w</span><span class="p">:</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span> <span class="n">oplus</span> <span class="o">=</span> <span class="k">lambda</span> <span class="o">*</span><span class="n">x</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">)</span></div>



<div class="viewcode-block" id="determinized_as_dfa">
<a class="viewcode-back" href="../../pyfoma.html#pyfoma.algorithms.determinized_as_dfa">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">determinized_as_dfa</span><span class="p">(</span><span class="n">fst</span><span class="p">:</span> <span class="s1">&#39;FST&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;FST&#39;</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns a modified FST, determinized as a DFA with weight as part of label, then apply unweighted det.&quot;&quot;&quot;</span>
    <span class="n">newfst</span> <span class="o">=</span> <span class="n">fst</span><span class="o">.</span><span class="n">copy_mod</span><span class="p">(</span><span class="n">modlabel</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">l</span><span class="p">,</span> <span class="n">w</span><span class="p">:</span> <span class="n">l</span> <span class="o">+</span> <span class="p">(</span><span class="n">w</span><span class="p">,),</span> <span class="n">modweight</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">l</span><span class="p">,</span> <span class="n">w</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">)</span>
    <span class="n">determinized</span> <span class="o">=</span> <span class="n">determinized_unweighted</span><span class="p">(</span><span class="n">newfst</span><span class="p">)</span> <span class="c1"># run det, then move weights back</span>
    <span class="k">return</span> <span class="n">determinized</span><span class="o">.</span><span class="n">copy_mod</span><span class="p">(</span><span class="n">modlabel</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">l</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">l</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">modweight</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">l</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">l</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span></div>



<div class="viewcode-block" id="determinized">
<a class="viewcode-back" href="../../pyfoma.html#pyfoma.algorithms.determinized">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">determinized</span><span class="p">(</span><span class="n">fst</span><span class="p">:</span> <span class="s1">&#39;FST&#39;</span><span class="p">,</span> <span class="n">staterep</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">s</span><span class="p">,</span> <span class="n">w</span><span class="p">:</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">w</span><span class="p">),</span> <span class="n">oplus</span> <span class="o">=</span> <span class="nb">min</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;FST&#39;</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns a modified FST, by weighted determinization of FST.&quot;&quot;&quot;</span>
    <span class="n">newfst</span> <span class="o">=</span> <span class="n">FST</span><span class="p">(</span><span class="n">alphabet</span> <span class="o">=</span> <span class="n">fst</span><span class="o">.</span><span class="n">alphabet</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
    <span class="n">firststate</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">({</span><span class="n">staterep</span><span class="p">(</span><span class="n">fst</span><span class="o">.</span><span class="n">initialstate</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)})</span>
    <span class="n">statesets</span> <span class="o">=</span> <span class="p">{</span><span class="n">firststate</span><span class="p">:</span><span class="n">newfst</span><span class="o">.</span><span class="n">initialstate</span><span class="p">}</span>
    <span class="k">if</span> <span class="n">fst</span><span class="o">.</span><span class="n">initialstate</span> <span class="ow">in</span> <span class="n">fst</span><span class="o">.</span><span class="n">finalstates</span><span class="p">:</span>
        <span class="n">newfst</span><span class="o">.</span><span class="n">finalstates</span> <span class="o">=</span> <span class="p">{</span><span class="n">newfst</span><span class="o">.</span><span class="n">initialstate</span><span class="p">}</span>
        <span class="n">newfst</span><span class="o">.</span><span class="n">initialstate</span><span class="o">.</span><span class="n">finalweight</span> <span class="o">=</span> <span class="n">fst</span><span class="o">.</span><span class="n">initialstate</span><span class="o">.</span><span class="n">finalweight</span>

    <span class="n">Q</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="n">firststate</span><span class="p">])</span>
    <span class="k">while</span> <span class="n">Q</span><span class="p">:</span>
        <span class="n">currentQ</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">collectlabels</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># temp dict of label:all transitions {(src1, trans1),...}</span>
        <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">currentQ</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">label</span><span class="p">,</span> <span class="n">transitions</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">transitions</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">transitions</span><span class="p">:</span>
                    <span class="n">collectlabels</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="n">collectlabels</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="nb">set</span><span class="p">())</span> <span class="o">|</span> <span class="p">{(</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">)}</span>

        <span class="n">residuals</span> <span class="o">=</span> <span class="p">{</span><span class="n">s</span><span class="p">:</span><span class="n">r</span> <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">currentQ</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">label</span><span class="p">,</span> <span class="n">tset</span> <span class="ow">in</span> <span class="n">collectlabels</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># wprime is the maximum amount the matching outgoing arcs share -</span>
            <span class="c1"># some paths may therefore accumulate debt which needs to be passed on</span>
            <span class="c1"># and stored in the next state representation for future discharge</span>
            <span class="n">wprime</span> <span class="o">=</span> <span class="n">oplus</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">weight</span> <span class="o">+</span> <span class="n">residuals</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tset</span><span class="p">)</span>
            <span class="c1"># Note the calculation of the weight debt we pass forward, reused w/ finals below</span>
            <span class="n">newQ</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">staterep</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">targetstate</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">weight</span> <span class="o">+</span> <span class="n">residuals</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">-</span> <span class="n">wprime</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tset</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">newQ</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">statesets</span><span class="p">:</span>
                <span class="n">Q</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newQ</span><span class="p">)</span>
                <span class="n">newstate</span> <span class="o">=</span> <span class="n">State</span><span class="p">()</span>
                <span class="n">statesets</span><span class="p">[</span><span class="n">newQ</span><span class="p">]</span> <span class="o">=</span> <span class="n">newstate</span>
                <span class="n">newfst</span><span class="o">.</span><span class="n">states</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">statesets</span><span class="p">[</span><span class="n">newQ</span><span class="p">])</span>
                <span class="c1">#statesets[newQ].name = {(s.name, w) if w != 0.0 else s.name for s, w in newQ}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">newstate</span> <span class="o">=</span> <span class="n">statesets</span><span class="p">[</span><span class="n">newQ</span><span class="p">]</span>
            <span class="n">statesets</span><span class="p">[</span><span class="n">currentQ</span><span class="p">]</span><span class="o">.</span><span class="n">add_transition</span><span class="p">(</span><span class="n">newstate</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">wprime</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">targetstate</span> <span class="ow">in</span> <span class="n">fst</span><span class="o">.</span><span class="n">finalstates</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tset</span><span class="p">):</span>
                <span class="n">newfst</span><span class="o">.</span><span class="n">finalstates</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">newstate</span><span class="p">)</span>
                <span class="c1"># State was final, so we discharge the maximum debt we can</span>
                <span class="n">newstate</span><span class="o">.</span><span class="n">finalweight</span> <span class="o">=</span> <span class="n">oplus</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">targetstate</span><span class="o">.</span><span class="n">finalweight</span> <span class="o">+</span> <span class="n">t</span><span class="o">.</span><span class="n">weight</span> <span class="o">+</span> \
                    <span class="n">residuals</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">-</span> <span class="n">wprime</span> <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tset</span> <span class="k">if</span> <span class="n">t</span><span class="o">.</span><span class="n">targetstate</span> <span class="ow">in</span> <span class="n">fst</span><span class="o">.</span><span class="n">finalstates</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">newfst</span></div>



<div class="viewcode-block" id="minimized_as_dfa">
<a class="viewcode-back" href="../../pyfoma.html#pyfoma.algorithms.minimized_as_dfa">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">minimized_as_dfa</span><span class="p">(</span><span class="n">fst</span><span class="p">:</span> <span class="s1">&#39;FST&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;FST&#39;</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns a modified FST, minimized as a DFA with weight as part of label, then apply unweighted min.&quot;&quot;&quot;</span>
    <span class="n">newfst</span> <span class="o">=</span> <span class="n">fst</span><span class="o">.</span><span class="n">copy_mod</span><span class="p">(</span><span class="n">modlabel</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">l</span><span class="p">,</span> <span class="n">w</span><span class="p">:</span> <span class="n">l</span> <span class="o">+</span> <span class="p">(</span><span class="n">w</span><span class="p">,),</span> <span class="n">modweight</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">l</span><span class="p">,</span> <span class="n">w</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">)</span>
    <span class="n">minimized_fst</span> <span class="o">=</span> <span class="n">minimized</span><span class="p">(</span><span class="n">newfst</span><span class="p">)</span> <span class="c1"># minimize, and shift weights back</span>
    <span class="k">return</span> <span class="n">minimized_fst</span><span class="o">.</span><span class="n">copy_mod</span><span class="p">(</span><span class="n">modlabel</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">l</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">l</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">modweight</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">l</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">l</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span></div>



<div class="viewcode-block" id="minimized">
<a class="viewcode-back" href="../../pyfoma.html#pyfoma.algorithms.minimized">[docs]</a>
<span class="nd">@_copy_param</span>
<span class="k">def</span><span class="w"> </span><span class="nf">minimized</span><span class="p">(</span><span class="n">fst</span><span class="p">:</span> <span class="s1">&#39;FST&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;FST&#39;</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns a modified FST, minimized by constrained reverse subset construction, Hopcroft-ish.&quot;&quot;&quot;</span>
    <span class="n">reverse_index</span> <span class="o">=</span> <span class="n">create_reverse_index</span><span class="p">(</span><span class="n">fst</span><span class="p">)</span>
    <span class="n">finalset</span><span class="p">,</span> <span class="n">nonfinalset</span> <span class="o">=</span> <span class="n">fst</span><span class="o">.</span><span class="n">finalstates</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">fst</span><span class="o">.</span><span class="n">states</span> <span class="o">-</span> <span class="n">fst</span><span class="o">.</span><span class="n">finalstates</span>
    <span class="n">initialpartition</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">(</span><span class="n">finalset</span><span class="p">,</span> <span class="n">nonfinalset</span><span class="p">)</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">P</span> <span class="o">=</span> <span class="n">partition_refinement</span><span class="o">.</span><span class="n">PartitionRefinement</span><span class="p">(</span><span class="n">initialpartition</span><span class="p">)</span>
    <span class="n">Agenda</span> <span class="o">=</span> <span class="p">{</span><span class="nb">id</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">(</span><span class="n">finalset</span><span class="p">,</span> <span class="n">nonfinalset</span><span class="p">)</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">}</span>
    <span class="k">while</span> <span class="n">Agenda</span><span class="p">:</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">sets</span><span class="p">[</span><span class="n">Agenda</span><span class="o">.</span><span class="n">pop</span><span class="p">()]</span> <span class="c1"># convert id to the actual set it corresponds to</span>
        <span class="k">for</span> <span class="n">label</span><span class="p">,</span> <span class="n">sourcestates</span> <span class="ow">in</span> <span class="n">find_sourcestates</span><span class="p">(</span><span class="n">fst</span><span class="p">,</span> <span class="n">reverse_index</span><span class="p">,</span> <span class="n">S</span><span class="p">):</span>
            <span class="n">splits</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">refine</span><span class="p">(</span><span class="n">sourcestates</span><span class="p">)</span> <span class="c1"># returns list of (A &amp; S, A - S) tuples</span>
            <span class="n">Agenda</span> <span class="o">|=</span> <span class="p">{</span><span class="n">new</span> <span class="k">for</span> <span class="n">new</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">splits</span><span class="p">}</span> <span class="c1"># Only place A &amp; S on Agenda</span>
    <span class="n">equivalenceclasses</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">astuples</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">equivalenceclasses</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">fst</span><span class="o">.</span><span class="n">states</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">fst</span> <span class="c1"># we were already minimal, no need to reconstruct</span>

    <span class="k">return</span> <span class="n">merging_equivalent_states</span><span class="p">(</span><span class="n">fst</span><span class="p">,</span> <span class="n">equivalenceclasses</span><span class="p">)</span></div>



<div class="viewcode-block" id="merging_equivalent_states">
<a class="viewcode-back" href="../../pyfoma.html#pyfoma.algorithms.merging_equivalent_states">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">merging_equivalent_states</span><span class="p">(</span><span class="n">fst</span><span class="p">:</span> <span class="s1">&#39;FST&#39;</span><span class="p">,</span> <span class="n">equivalenceclasses</span><span class="p">:</span> <span class="nb">set</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;FST&#39;</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Merge equivalent states given as a set of sets.&quot;&quot;&quot;</span>
    <span class="n">eqmap</span> <span class="o">=</span> <span class="p">{</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">equivalenceclasses</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">))}</span>
    <span class="n">representerstates</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">eqmap</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    <span class="n">newfst</span> <span class="o">=</span> <span class="n">FST</span><span class="p">(</span><span class="n">alphabet</span> <span class="o">=</span> <span class="n">fst</span><span class="o">.</span><span class="n">alphabet</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
    <span class="n">statemap</span> <span class="o">=</span> <span class="p">{</span><span class="n">s</span><span class="p">:</span><span class="n">State</span><span class="p">()</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">fst</span><span class="o">.</span><span class="n">states</span> <span class="k">if</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">representerstates</span><span class="p">}</span>
    <span class="n">newfst</span><span class="o">.</span><span class="n">initialstate</span> <span class="o">=</span> <span class="n">statemap</span><span class="p">[</span><span class="n">eqmap</span><span class="p">[</span><span class="n">fst</span><span class="o">.</span><span class="n">initialstate</span><span class="p">]]</span>
    <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">lbl</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">fst</span><span class="o">.</span><span class="n">all_transitions</span><span class="p">(</span><span class="n">fst</span><span class="o">.</span><span class="n">states</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">representerstates</span><span class="p">:</span>
            <span class="n">statemap</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">add_transition</span><span class="p">(</span><span class="n">statemap</span><span class="p">[</span><span class="n">eqmap</span><span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">targetstate</span><span class="p">]],</span> <span class="n">lbl</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">weight</span><span class="p">)</span>
    <span class="n">newfst</span><span class="o">.</span><span class="n">states</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">statemap</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    <span class="n">newfst</span><span class="o">.</span><span class="n">finalstates</span> <span class="o">=</span> <span class="p">{</span><span class="n">statemap</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">fst</span><span class="o">.</span><span class="n">finalstates</span> <span class="k">if</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">representerstates</span><span class="p">}</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">fst</span><span class="o">.</span><span class="n">finalstates</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">representerstates</span><span class="p">:</span>
            <span class="n">statemap</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">finalweight</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">finalweight</span>
    <span class="k">return</span> <span class="n">newfst</span></div>



<div class="viewcode-block" id="find_sourcestates">
<a class="viewcode-back" href="../../pyfoma.html#pyfoma.algorithms.find_sourcestates">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">find_sourcestates</span><span class="p">(</span><span class="n">fst</span><span class="p">:</span> <span class="s1">&#39;FST&#39;</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">stateset</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create generator that yields sourcestates for a set of target states.</span>
<span class="sd">       Yields the label, and the set of sourcestates.&quot;&quot;&quot;</span>
    <span class="n">all_labels</span> <span class="o">=</span> <span class="p">{</span><span class="n">l</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">stateset</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">index</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>
    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">all_labels</span><span class="p">:</span>
        <span class="n">sources</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">stateset</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">index</span><span class="p">[</span><span class="n">state</span><span class="p">]:</span>
                <span class="n">sources</span> <span class="o">|=</span> <span class="n">index</span><span class="p">[</span><span class="n">state</span><span class="p">][</span><span class="n">l</span><span class="p">]</span>
        <span class="k">yield</span> <span class="n">l</span><span class="p">,</span> <span class="n">sources</span></div>



<div class="viewcode-block" id="create_reverse_index">
<a class="viewcode-back" href="../../pyfoma.html#pyfoma.algorithms.create_reverse_index">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">create_reverse_index</span><span class="p">(</span><span class="n">fst</span><span class="p">:</span> <span class="s1">&#39;FST&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns dictionary of transitions in reverse (indexed by state).&quot;&quot;&quot;</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="p">{</span><span class="n">s</span><span class="p">:{}</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">fst</span><span class="o">.</span><span class="n">states</span><span class="p">}</span>
    <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">lbl</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">fst</span><span class="o">.</span><span class="n">all_transitions</span><span class="p">(</span><span class="n">fst</span><span class="o">.</span><span class="n">states</span><span class="p">):</span>
        <span class="n">idx</span><span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">targetstate</span><span class="p">][</span><span class="n">lbl</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">targetstate</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">lbl</span><span class="p">,</span> <span class="nb">set</span><span class="p">())</span> <span class="o">|</span> <span class="p">{</span><span class="n">s</span><span class="p">}</span>
    <span class="k">return</span> <span class="n">idx</span></div>



<div class="viewcode-block" id="minimized_brz">
<a class="viewcode-back" href="../../pyfoma.html#pyfoma.algorithms.minimized_brz">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">minimized_brz</span><span class="p">(</span><span class="n">fst</span><span class="p">:</span> <span class="s1">&#39;FST&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;FST&#39;</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns a modified FST, minimized through Brzozowski&#39;s trick.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">determinized</span><span class="p">(</span><span class="n">reversed_e</span><span class="p">(</span><span class="n">determinized</span><span class="p">(</span><span class="n">reversed_e</span><span class="p">(</span><span class="n">epsilon_removed</span><span class="p">(</span><span class="n">fst</span><span class="p">)))))</span></div>



<div class="viewcode-block" id="kleene_closure">
<a class="viewcode-back" href="../../pyfoma.html#pyfoma.algorithms.kleene_closure">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">kleene_closure</span><span class="p">(</span><span class="n">fst</span><span class="p">:</span> <span class="s1">&#39;FST&#39;</span><span class="p">,</span> <span class="n">mode</span> <span class="o">=</span> <span class="s1">&#39;star&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;FST&#39;</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns a modified FST, applying self*. No epsilons here. If mode == &#39;plus&#39;, calculate self+.&quot;&quot;&quot;</span>
    <span class="n">q1</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="n">State</span><span class="p">()</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">fst</span><span class="o">.</span><span class="n">states</span><span class="p">}</span>
    <span class="n">newfst</span> <span class="o">=</span> <span class="n">FST</span><span class="p">(</span><span class="n">alphabet</span> <span class="o">=</span> <span class="n">fst</span><span class="o">.</span><span class="n">alphabet</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>

    <span class="k">for</span> <span class="n">lbl</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">fst</span><span class="o">.</span><span class="n">initialstate</span><span class="o">.</span><span class="n">all_transitions</span><span class="p">():</span>
        <span class="n">newfst</span><span class="o">.</span><span class="n">initialstate</span><span class="o">.</span><span class="n">add_transition</span><span class="p">(</span><span class="n">q1</span><span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">targetstate</span><span class="p">],</span> <span class="n">lbl</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">weight</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">lbl</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">fst</span><span class="o">.</span><span class="n">all_transitions</span><span class="p">(</span><span class="n">fst</span><span class="o">.</span><span class="n">states</span><span class="p">):</span>
        <span class="n">q1</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">add_transition</span><span class="p">(</span><span class="n">q1</span><span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">targetstate</span><span class="p">],</span> <span class="n">lbl</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">weight</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">fst</span><span class="o">.</span><span class="n">finalstates</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">lbl</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">fst</span><span class="o">.</span><span class="n">initialstate</span><span class="o">.</span><span class="n">all_transitions</span><span class="p">():</span>
            <span class="n">q1</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">add_transition</span><span class="p">(</span><span class="n">q1</span><span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">targetstate</span><span class="p">],</span> <span class="n">lbl</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">weight</span><span class="p">)</span>
        <span class="n">q1</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">finalweight</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">finalweight</span>

    <span class="n">newfst</span><span class="o">.</span><span class="n">finalstates</span> <span class="o">=</span> <span class="p">{</span><span class="n">q1</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">fst</span><span class="o">.</span><span class="n">finalstates</span><span class="p">}</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="o">!=</span> <span class="s1">&#39;plus&#39;</span> <span class="ow">or</span> <span class="n">fst</span><span class="o">.</span><span class="n">initialstate</span> <span class="ow">in</span> <span class="n">fst</span><span class="o">.</span><span class="n">finalstates</span><span class="p">:</span>
        <span class="n">newfst</span><span class="o">.</span><span class="n">finalstates</span> <span class="o">|=</span> <span class="p">{</span><span class="n">newfst</span><span class="o">.</span><span class="n">initialstate</span><span class="p">}</span>
        <span class="n">newfst</span><span class="o">.</span><span class="n">initialstate</span><span class="o">.</span><span class="n">finalweight</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">newfst</span><span class="o">.</span><span class="n">states</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">q1</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">|</span> <span class="p">{</span><span class="n">newfst</span><span class="o">.</span><span class="n">initialstate</span><span class="p">}</span>
    <span class="k">return</span> <span class="n">newfst</span></div>



<div class="viewcode-block" id="kleene_star">
<a class="viewcode-back" href="../../pyfoma.html#pyfoma.algorithms.kleene_star">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">kleene_star</span><span class="p">(</span><span class="n">fst</span><span class="p">:</span> <span class="s1">&#39;FST&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;FST&#39;</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns a modified FST, applying self*.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">kleene_closure</span><span class="p">(</span><span class="n">fst</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;star&#39;</span><span class="p">)</span></div>



<div class="viewcode-block" id="kleene_plus">
<a class="viewcode-back" href="../../pyfoma.html#pyfoma.algorithms.kleene_plus">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">kleene_plus</span><span class="p">(</span><span class="n">fst</span><span class="p">:</span> <span class="s1">&#39;FST&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;FST&#39;</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns a modified FST, applying self+.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">kleene_closure</span><span class="p">(</span><span class="n">fst</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;plus&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="eliminate_flags">
<a class="viewcode-back" href="../../pyfoma.html#pyfoma.algorithms.eliminate_flags">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">eliminate_flags</span><span class="p">(</span><span class="n">fst</span><span class="p">:</span> <span class="s1">&#39;FST&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;FST&#39;</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a modified FST, having equivalent behavior but no flag diacritics.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">eliminate_fst_flags</span><span class="p">(</span><span class="n">fst</span><span class="p">)</span></div>


<div class="viewcode-block" id="added_weight">
<a class="viewcode-back" href="../../pyfoma.html#pyfoma.algorithms.added_weight">[docs]</a>
<span class="nd">@_copy_param</span>
<span class="k">def</span><span class="w"> </span><span class="nf">added_weight</span><span class="p">(</span><span class="n">fst</span><span class="p">:</span> <span class="s1">&#39;FST&#39;</span><span class="p">,</span> <span class="n">weight</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;FST&#39;</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns a modified FST, adding weight to the set of final states in the FST.&quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">fst</span><span class="o">.</span><span class="n">finalstates</span><span class="p">:</span>
        <span class="n">s</span><span class="o">.</span><span class="n">finalweight</span> <span class="o">+=</span> <span class="n">weight</span>
    <span class="k">return</span> <span class="n">fst</span></div>



<div class="viewcode-block" id="optional">
<a class="viewcode-back" href="../../pyfoma.html#pyfoma.algorithms.optional">[docs]</a>
<span class="nd">@_copy_param</span>
<span class="k">def</span><span class="w"> </span><span class="nf">optional</span><span class="p">(</span><span class="n">fst</span><span class="p">:</span> <span class="s1">&#39;FST&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;FST&#39;</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns a modified FST, calculated as T|&#39;&#39; .&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">fst</span><span class="o">.</span><span class="n">initialstate</span> <span class="ow">in</span> <span class="n">fst</span><span class="o">.</span><span class="n">finalstates</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">fst</span>
    <span class="n">newinitial</span> <span class="o">=</span> <span class="n">State</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">lbl</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">fst</span><span class="o">.</span><span class="n">initialstate</span><span class="o">.</span><span class="n">all_transitions</span><span class="p">():</span>
        <span class="n">newinitial</span><span class="o">.</span><span class="n">add_transition</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">targetstate</span><span class="p">,</span> <span class="n">lbl</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">weight</span><span class="p">)</span>

    <span class="n">fst</span><span class="o">.</span><span class="n">initialstate</span> <span class="o">=</span> <span class="n">newinitial</span>
    <span class="n">fst</span><span class="o">.</span><span class="n">states</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">newinitial</span><span class="p">)</span>
    <span class="n">fst</span><span class="o">.</span><span class="n">finalstates</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">newinitial</span><span class="p">)</span>
    <span class="n">newinitial</span><span class="o">.</span><span class="n">finalweight</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">return</span> <span class="n">fst</span></div>



<div class="viewcode-block" id="concatenate">
<a class="viewcode-back" href="../../pyfoma.html#pyfoma.algorithms.concatenate">[docs]</a>
<span class="nd">@_harmonize_alphabet</span>
<span class="k">def</span><span class="w"> </span><span class="nf">concatenate</span><span class="p">(</span><span class="n">fst1</span><span class="p">:</span> <span class="s1">&#39;FST&#39;</span><span class="p">,</span> <span class="n">fst2</span><span class="p">:</span> <span class="s1">&#39;FST&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;FST&#39;</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Concatenation of T1T2. No epsilons. May produce non-accessible states.&quot;&quot;&quot;</span>
    <span class="n">ocopy</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">fst2</span><span class="o">.</span><span class="n">copy_filtered</span><span class="p">()</span> <span class="c1"># Need to copy since self may equal other</span>
    <span class="n">q1q2</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="n">State</span><span class="p">()</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">fst1</span><span class="o">.</span><span class="n">states</span> <span class="o">|</span> <span class="n">ocopy</span><span class="o">.</span><span class="n">states</span><span class="p">}</span>

    <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">lbl</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">fst1</span><span class="o">.</span><span class="n">all_transitions</span><span class="p">(</span><span class="n">q1q2</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
        <span class="n">q1q2</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">add_transition</span><span class="p">(</span><span class="n">q1q2</span><span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">targetstate</span><span class="p">],</span> <span class="n">lbl</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">weight</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">fst1</span><span class="o">.</span><span class="n">finalstates</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">lbl2</span><span class="p">,</span> <span class="n">t2</span> <span class="ow">in</span> <span class="n">ocopy</span><span class="o">.</span><span class="n">initialstate</span><span class="o">.</span><span class="n">all_transitions</span><span class="p">():</span>
            <span class="n">q1q2</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">add_transition</span><span class="p">(</span><span class="n">q1q2</span><span class="p">[</span><span class="n">t2</span><span class="o">.</span><span class="n">targetstate</span><span class="p">],</span> <span class="n">lbl2</span><span class="p">,</span> <span class="n">t2</span><span class="o">.</span><span class="n">weight</span> <span class="o">+</span> <span class="n">s</span><span class="o">.</span><span class="n">finalweight</span><span class="p">)</span>

    <span class="n">newfst</span> <span class="o">=</span> <span class="n">FST</span><span class="p">()</span>
    <span class="n">newfst</span><span class="o">.</span><span class="n">initialstate</span> <span class="o">=</span> <span class="n">q1q2</span><span class="p">[</span><span class="n">fst1</span><span class="o">.</span><span class="n">initialstate</span><span class="p">]</span>
    <span class="n">newfst</span><span class="o">.</span><span class="n">finalstates</span> <span class="o">=</span> <span class="p">{</span><span class="n">q1q2</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">ocopy</span><span class="o">.</span><span class="n">finalstates</span><span class="p">}</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">ocopy</span><span class="o">.</span><span class="n">finalstates</span><span class="p">:</span>
        <span class="n">q1q2</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">finalweight</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">finalweight</span>
    <span class="k">if</span> <span class="n">ocopy</span><span class="o">.</span><span class="n">initialstate</span> <span class="ow">in</span> <span class="n">ocopy</span><span class="o">.</span><span class="n">finalstates</span><span class="p">:</span>
        <span class="n">newfst</span><span class="o">.</span><span class="n">finalstates</span> <span class="o">|=</span> <span class="p">{</span><span class="n">q1q2</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fst1</span><span class="o">.</span><span class="n">finalstates</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fst1</span><span class="o">.</span><span class="n">finalstates</span><span class="p">:</span>
            <span class="n">q1q2</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">.</span><span class="n">finalweight</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">finalweight</span> <span class="o">+</span> <span class="n">ocopy</span><span class="o">.</span><span class="n">initialstate</span><span class="o">.</span><span class="n">finalweight</span>
    <span class="n">newfst</span><span class="o">.</span><span class="n">states</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">q1q2</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">newfst</span></div>



<div class="viewcode-block" id="cross_product">
<a class="viewcode-back" href="../../pyfoma.html#pyfoma.algorithms.cross_product">[docs]</a>
<span class="nd">@_harmonize_alphabet</span>
<span class="k">def</span><span class="w"> </span><span class="nf">cross_product</span><span class="p">(</span><span class="n">fst1</span><span class="p">:</span> <span class="s1">&#39;FST&#39;</span><span class="p">,</span> <span class="n">fst2</span><span class="p">:</span> <span class="s1">&#39;FST&#39;</span><span class="p">,</span> <span class="n">optional</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;FST&#39;</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Perform the cross-product of T1, T2 through composition.</span>
<span class="sd">       Keyword arguments:</span>
<span class="sd">       optional -- if True, calculates T1:T2 | T1.&quot;&quot;&quot;</span>
    <span class="n">newfst_a</span> <span class="o">=</span> <span class="n">fst1</span><span class="o">.</span><span class="n">copy_mod</span><span class="p">(</span><span class="n">modlabel</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">l</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">l</span> <span class="o">+</span> <span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,))</span>
    <span class="n">newfst_b</span> <span class="o">=</span> <span class="n">fst2</span><span class="o">.</span><span class="n">copy_mod</span><span class="p">(</span><span class="n">modlabel</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">l</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,)</span> <span class="o">+</span> <span class="n">l</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">optional</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">union</span><span class="p">(</span><span class="n">compose</span><span class="p">(</span><span class="n">newfst_a</span><span class="p">,</span> <span class="n">newfst_b</span><span class="p">),</span> <span class="n">fst1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">compose</span><span class="p">(</span><span class="n">newfst_a</span><span class="p">,</span> <span class="n">newfst_b</span><span class="p">)</span></div>



<div class="viewcode-block" id="compose">
<a class="viewcode-back" href="../../pyfoma.html#pyfoma.algorithms.compose">[docs]</a>
<span class="nd">@_harmonize_alphabet</span>
<span class="k">def</span><span class="w"> </span><span class="nf">compose</span><span class="p">(</span><span class="n">fst1</span><span class="p">:</span> <span class="s1">&#39;FST&#39;</span><span class="p">,</span> <span class="n">fst2</span><span class="p">:</span> <span class="s1">&#39;FST&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;FST&#39;</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Composition of A,B; will expand an acceptor into 2-tape FST on-the-fly.&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_mergetuples</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">y</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">))):</span>
            <span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],)</span>
        <span class="k">return</span> <span class="n">t</span>

    <span class="c1"># Mode 0: allow A=x:0 B=0:y (&gt;0), A=x:y B=y:z (&gt;0), A=x:0 B=wait (&gt;1) A=wait 0:y (&gt;2)</span>
    <span class="c1"># Mode 1: x:0 B=wait (&gt;1), x:y y:z (&gt;0)</span>
    <span class="c1"># Mode 2: A=wait 0:y (&gt;2), x:y y:z (&gt;0)</span>

    <span class="n">newfst</span> <span class="o">=</span> <span class="n">FST</span><span class="p">()</span>
    <span class="n">Q</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([(</span><span class="n">fst1</span><span class="o">.</span><span class="n">initialstate</span><span class="p">,</span> <span class="n">fst2</span><span class="o">.</span><span class="n">initialstate</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
    <span class="n">S</span> <span class="o">=</span> <span class="p">{(</span><span class="n">fst1</span><span class="o">.</span><span class="n">initialstate</span><span class="p">,</span> <span class="n">fst2</span><span class="o">.</span><span class="n">initialstate</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span> <span class="n">newfst</span><span class="o">.</span><span class="n">initialstate</span><span class="p">}</span>
    <span class="k">while</span> <span class="n">Q</span><span class="p">:</span>
        <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">mode</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">currentstate</span> <span class="o">=</span> <span class="n">S</span><span class="p">[(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">mode</span><span class="p">)]</span>
        <span class="n">currentstate</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;(</span><span class="si">{}</span><span class="s2">,</span><span class="si">{}</span><span class="s2">,</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">B</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">A</span> <span class="ow">in</span> <span class="n">fst1</span><span class="o">.</span><span class="n">finalstates</span> <span class="ow">and</span> <span class="n">B</span> <span class="ow">in</span> <span class="n">fst2</span><span class="o">.</span><span class="n">finalstates</span><span class="p">:</span>
            <span class="n">newfst</span><span class="o">.</span><span class="n">finalstates</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">currentstate</span><span class="p">)</span>
            <span class="n">currentstate</span><span class="o">.</span><span class="n">finalweight</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">finalweight</span> <span class="o">+</span> <span class="n">B</span><span class="o">.</span><span class="n">finalweight</span> <span class="c1"># TODO: oplus</span>
        <span class="k">for</span> <span class="n">matchsym</span> <span class="ow">in</span> <span class="n">A</span><span class="o">.</span><span class="n">transitionsout</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">matchsym</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span><span class="p">:</span> <span class="c1"># A=x:y B=y:z, or x:0 0:y (only in mode 0)</span>
                <span class="k">for</span> <span class="n">outtrans</span> <span class="ow">in</span> <span class="n">A</span><span class="o">.</span><span class="n">transitionsout</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">matchsym</span><span class="p">,</span> <span class="p">()):</span>
                    <span class="k">for</span> <span class="n">intrans</span> <span class="ow">in</span> <span class="n">B</span><span class="o">.</span><span class="n">transitionsin</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">matchsym</span><span class="p">,</span> <span class="p">()):</span>
                        <span class="n">target1</span> <span class="o">=</span> <span class="n">outtrans</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">targetstate</span> <span class="c1"># Transition</span>
                        <span class="n">target2</span> <span class="o">=</span> <span class="n">intrans</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">targetstate</span>  <span class="c1"># Transition</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">target1</span><span class="p">,</span> <span class="n">target2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">S</span><span class="p">:</span>
                            <span class="n">Q</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">target1</span><span class="p">,</span> <span class="n">target2</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
                            <span class="n">S</span><span class="p">[(</span><span class="n">target1</span><span class="p">,</span> <span class="n">target2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">=</span> <span class="n">State</span><span class="p">()</span>
                            <span class="n">newfst</span><span class="o">.</span><span class="n">states</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">S</span><span class="p">[(</span><span class="n">target1</span><span class="p">,</span> <span class="n">target2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
                        <span class="c1"># Keep intermediate</span>
                        <span class="c1"># currentstate.add_transition(S[(target1, target2)], outtrans[1].label[:-1] + intrans[1].label, outtrans[1].weight + intrans[1].weight)</span>
                        <span class="n">newlabel</span> <span class="o">=</span> <span class="n">_mergetuples</span><span class="p">(</span><span class="n">outtrans</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">intrans</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">label</span><span class="p">)</span>
                        <span class="n">currentstate</span><span class="o">.</span><span class="n">add_transition</span><span class="p">(</span><span class="n">S</span><span class="p">[(</span><span class="n">target1</span><span class="p">,</span> <span class="n">target2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span> <span class="n">newlabel</span><span class="p">,</span> <span class="n">outtrans</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">weight</span> <span class="o">+</span> <span class="n">intrans</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">weight</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">outtrans</span> <span class="ow">in</span> <span class="n">A</span><span class="o">.</span><span class="n">transitionsout</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="p">()):</span> <span class="c1"># B waits</span>
            <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">target1</span><span class="p">,</span> <span class="n">target2</span> <span class="o">=</span> <span class="n">outtrans</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">targetstate</span><span class="p">,</span> <span class="n">B</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">target1</span><span class="p">,</span> <span class="n">target2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">S</span><span class="p">:</span>
                <span class="n">Q</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">target1</span><span class="p">,</span> <span class="n">target2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
                <span class="n">S</span><span class="p">[(</span><span class="n">target1</span><span class="p">,</span> <span class="n">target2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">State</span><span class="p">()</span>
                <span class="n">newfst</span><span class="o">.</span><span class="n">states</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">S</span><span class="p">[(</span><span class="n">target1</span><span class="p">,</span> <span class="n">target2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)])</span>
            <span class="n">newlabel</span> <span class="o">=</span> <span class="n">outtrans</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">label</span>
            <span class="n">currentstate</span><span class="o">.</span><span class="n">add_transition</span><span class="p">(</span><span class="n">S</span><span class="p">[(</span><span class="n">target1</span><span class="p">,</span> <span class="n">target2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span> <span class="n">newlabel</span><span class="p">,</span> <span class="n">outtrans</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">weight</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">intrans</span> <span class="ow">in</span> <span class="n">B</span><span class="o">.</span><span class="n">transitionsin</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="p">()):</span> <span class="c1"># A waits</span>
            <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">target1</span><span class="p">,</span> <span class="n">target2</span> <span class="o">=</span> <span class="n">A</span><span class="p">,</span> <span class="n">intrans</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">targetstate</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">target1</span><span class="p">,</span> <span class="n">target2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">S</span><span class="p">:</span>
                <span class="n">Q</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">target1</span><span class="p">,</span> <span class="n">target2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
                <span class="n">S</span><span class="p">[(</span><span class="n">target1</span><span class="p">,</span> <span class="n">target2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)]</span> <span class="o">=</span> <span class="n">State</span><span class="p">()</span>
                <span class="n">newfst</span><span class="o">.</span><span class="n">states</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">S</span><span class="p">[(</span><span class="n">target1</span><span class="p">,</span> <span class="n">target2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)])</span>
            <span class="n">newlabel</span> <span class="o">=</span> <span class="n">intrans</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">label</span>
            <span class="n">currentstate</span><span class="o">.</span><span class="n">add_transition</span><span class="p">(</span><span class="n">S</span><span class="p">[(</span><span class="n">target1</span><span class="p">,</span> <span class="n">target2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)],</span> <span class="n">newlabel</span><span class="p">,</span> <span class="n">intrans</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">weight</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">newfst</span></div>



<div class="viewcode-block" id="inverted">
<a class="viewcode-back" href="../../pyfoma.html#pyfoma.algorithms.inverted">[docs]</a>
<span class="nd">@_copy_param</span>
<span class="k">def</span><span class="w"> </span><span class="nf">inverted</span><span class="p">(</span><span class="n">fst</span><span class="p">:</span> <span class="s1">&#39;FST&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;FST&#39;</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns a modified FST, calculating the inverse of a transducer, i.e. flips label tuples around.&quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">fst</span><span class="o">.</span><span class="n">states</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">lbl</span><span class="p">,</span> <span class="n">tr</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">transitions</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tr</span><span class="p">:</span>
                <span class="n">t</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">label</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">s</span><span class="o">.</span><span class="n">transitions</span> <span class="o">=</span> <span class="p">{</span><span class="n">lbl</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span><span class="n">tr</span> <span class="k">for</span> <span class="n">lbl</span><span class="p">,</span> <span class="n">tr</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">transitions</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    <span class="k">return</span> <span class="n">fst</span></div>



<div class="viewcode-block" id="ignore">
<a class="viewcode-back" href="../../pyfoma.html#pyfoma.algorithms.ignore">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">ignore</span><span class="p">(</span><span class="n">fst1</span><span class="p">:</span> <span class="s1">&#39;FST&#39;</span><span class="p">,</span> <span class="n">fst2</span><span class="p">:</span> <span class="s1">&#39;FST&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;FST&#39;</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A, ignoring intervening instances of B.&quot;&quot;&quot;</span>
    <span class="n">newfst</span> <span class="o">=</span> <span class="n">FST</span><span class="o">.</span><span class="n">re</span><span class="p">(</span><span class="s2">&quot;$^output($A @ (&#39;.&#39;|&#39;&#39;:$B)*)&quot;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="n">fst1</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="n">fst2</span><span class="p">})</span>
    <span class="k">return</span> <span class="n">newfst</span></div>



<div class="viewcode-block" id="rewritten">
<a class="viewcode-back" href="../../pyfoma.html#pyfoma.algorithms.rewritten">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">rewritten</span><span class="p">(</span><span class="n">fst</span><span class="p">:</span> <span class="s1">&#39;FST&#39;</span><span class="p">,</span> <span class="o">*</span><span class="n">contexts</span><span class="p">,</span> <span class="o">**</span><span class="n">flags</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;FST&#39;</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns a modified FST, rewriting self in contexts in parallel, controlled by flags.&quot;&quot;&quot;</span>
    <span class="n">defs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;crossproducts&#39;</span><span class="p">:</span> <span class="n">fst</span><span class="p">}</span>
    <span class="n">defs</span><span class="p">[</span><span class="s1">&#39;br&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">FST</span><span class="o">.</span><span class="n">re</span><span class="p">(</span><span class="s2">&quot;&#39;@&lt;@&#39;|&#39;@&gt;@&#39;&quot;</span><span class="p">)</span>
    <span class="n">defs</span><span class="p">[</span><span class="s1">&#39;aux&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">FST</span><span class="o">.</span><span class="n">re</span><span class="p">(</span><span class="s2">&quot;. - ($br|#)&quot;</span><span class="p">,</span> <span class="n">defs</span><span class="p">)</span>
    <span class="n">defs</span><span class="p">[</span><span class="s1">&#39;dotted&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">FST</span><span class="o">.</span><span class="n">re</span><span class="p">(</span><span class="s2">&quot;.*-(.* &#39;@&lt;@&#39; &#39;@&gt;@&#39; &#39;@&lt;@&#39; &#39;@&gt;@&#39; .*)&quot;</span><span class="p">)</span>
    <span class="n">defs</span><span class="p">[</span><span class="s1">&#39;base&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">FST</span><span class="o">.</span><span class="n">re</span><span class="p">(</span><span class="s2">&quot;$dotted @ # ($aux | &#39;@&lt;@&#39; $crossproducts &#39;@&gt;@&#39;)* #&quot;</span><span class="p">,</span> <span class="n">defs</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">contexts</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">center</span> <span class="o">=</span> <span class="n">FST</span><span class="o">.</span><span class="n">re</span><span class="p">(</span><span class="s2">&quot;&#39;@&lt;@&#39; (.-&#39;@&gt;@&#39;)* &#39;@&gt;@&#39;&quot;</span><span class="p">)</span>
        <span class="n">lrpairs</span> <span class="o">=</span> <span class="p">([</span><span class="n">l</span><span class="o">.</span><span class="n">ignore</span><span class="p">(</span><span class="n">defs</span><span class="p">[</span><span class="s1">&#39;br&#39;</span><span class="p">]),</span> <span class="n">r</span><span class="o">.</span><span class="n">ignore</span><span class="p">(</span><span class="n">defs</span><span class="p">[</span><span class="s1">&#39;br&#39;</span><span class="p">])]</span> <span class="k">for</span> <span class="n">l</span><span class="p">,</span><span class="n">r</span> <span class="ow">in</span> <span class="n">contexts</span><span class="p">)</span>
        <span class="n">defs</span><span class="p">[</span><span class="s1">&#39;rule&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">center</span><span class="o">.</span><span class="n">context_restrict</span><span class="p">(</span><span class="o">*</span><span class="n">lrpairs</span><span class="p">,</span> <span class="n">rewrite</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">compose</span><span class="p">(</span><span class="n">defs</span><span class="p">[</span><span class="s1">&#39;base&#39;</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">defs</span><span class="p">[</span><span class="s1">&#39;rule&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">defs</span><span class="p">[</span><span class="s1">&#39;base&#39;</span><span class="p">]</span>
    <span class="n">defs</span><span class="p">[</span><span class="s1">&#39;remrewr&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">FST</span><span class="o">.</span><span class="n">re</span><span class="p">(</span><span class="s2">&quot;&#39;@&lt;@&#39;:&#39;&#39; (.-&#39;@&gt;@&#39;)* &#39;@&gt;@&#39;:&#39;&#39;&quot;</span><span class="p">)</span> <span class="c1"># worsener</span>
    <span class="n">worseners</span> <span class="o">=</span> <span class="p">[</span><span class="n">FST</span><span class="o">.</span><span class="n">re</span><span class="p">(</span><span class="s2">&quot;.* $remrewr (.|$remrewr)*&quot;</span><span class="p">,</span> <span class="n">defs</span><span class="p">)]</span>
    <span class="k">if</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;longest&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;True&#39;</span><span class="p">:</span>
        <span class="n">worseners</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">FST</span><span class="o">.</span><span class="n">re</span><span class="p">(</span><span class="s2">&quot;.* &#39;@&lt;@&#39; $aux+ &#39;&#39;:(&#39;@&gt;@&#39; &#39;@&lt;@&#39;?) $aux ($br:&#39;&#39;|&#39;&#39;:$br|$aux)* .*&quot;</span><span class="p">,</span> <span class="n">defs</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;leftmost&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;True&#39;</span><span class="p">:</span>
        <span class="n">worseners</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">FST</span><span class="o">.</span><span class="n">re</span><span class="p">(</span>\
             <span class="s2">&quot;.* &#39;@&lt;@&#39;:&#39;&#39; $aux+ (&#39;&#39;:&#39;@&lt;@&#39; $aux* &#39;&#39;:&#39;@&gt;@&#39; $aux+ &#39;@&gt;@&#39;:&#39;&#39; .* | &#39;&#39;:&#39;@&lt;@&#39; $aux* &#39;@&gt;@&#39;:&#39;&#39; $aux* &#39;&#39;:&#39;@&gt;@&#39; .*)&quot;</span><span class="p">,</span> <span class="n">defs</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">flags</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;shortest&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;True&#39;</span><span class="p">:</span>
        <span class="n">worseners</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">FST</span><span class="o">.</span><span class="n">re</span><span class="p">(</span><span class="s2">&quot;.* &#39;@&lt;@&#39; $aux* &#39;@&gt;@&#39;:&#39;&#39; $aux+ &#39;&#39;:&#39;@&gt;@&#39; .*&quot;</span><span class="p">,</span> <span class="n">defs</span><span class="p">))</span>
    <span class="n">defs</span><span class="p">[</span><span class="s1">&#39;worsen&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">worseners</span><span class="p">)</span><span class="o">.</span><span class="n">determinize_unweighted</span><span class="p">()</span><span class="o">.</span><span class="n">minimize</span><span class="p">()</span>
    <span class="n">defs</span><span class="p">[</span><span class="s1">&#39;rewr&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">FST</span><span class="o">.</span><span class="n">re</span><span class="p">(</span><span class="s2">&quot;$^output($^input($rule) @ $worsen)&quot;</span><span class="p">,</span> <span class="n">defs</span><span class="p">)</span>
    <span class="n">final</span> <span class="o">=</span> <span class="n">FST</span><span class="o">.</span><span class="n">re</span><span class="p">(</span><span class="s2">&quot;(.* - $rewr) @ $rule&quot;</span><span class="p">,</span> <span class="n">defs</span><span class="p">)</span>
    <span class="n">newfst</span> <span class="o">=</span> <span class="n">final</span><span class="o">.</span><span class="n">map_labels</span><span class="p">({</span><span class="n">s</span><span class="p">:</span><span class="s1">&#39;&#39;</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;@&lt;@&#39;</span><span class="p">,</span><span class="s1">&#39;@&gt;@&#39;</span><span class="p">,</span><span class="s1">&#39;#&#39;</span><span class="p">]})</span><span class="o">.</span><span class="n">epsilon_remove</span><span class="p">()</span><span class="o">.</span><span class="n">determinize_as_dfa</span><span class="p">()</span><span class="o">.</span><span class="n">minimize</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">newfst</span></div>



<div class="viewcode-block" id="context_restricted">
<a class="viewcode-back" href="../../pyfoma.html#pyfoma.algorithms.context_restricted">[docs]</a>
<span class="nd">@_copy_param</span>
<span class="k">def</span><span class="w"> </span><span class="nf">context_restricted</span><span class="p">(</span><span class="n">fst</span><span class="p">:</span> <span class="s1">&#39;FST&#39;</span><span class="p">,</span> <span class="o">*</span><span class="n">contexts</span><span class="p">,</span> <span class="n">rewrite</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;FST&#39;</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns a modified FST, where self only allowed in the context L1 _ R1, or ... , or  L_n _ R_n.&quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">fsm</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">contexts</span><span class="p">):</span>
        <span class="n">fsm</span><span class="o">.</span><span class="n">alphabet</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;@=@&#39;</span><span class="p">)</span> <span class="c1"># Add aux sym to contexts so they don&#39;t match .</span>
    <span class="n">fst</span><span class="o">.</span><span class="n">alphabet</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;@=@&#39;</span><span class="p">)</span>    <span class="c1"># Same for self</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">rewrite</span><span class="p">:</span>
        <span class="n">cs</span> <span class="o">=</span> <span class="p">(</span><span class="n">FST</span><span class="o">.</span><span class="n">re</span><span class="p">(</span><span class="s2">&quot;$lc &#39;@=@&#39; (.-&#39;@=@&#39;)* &#39;@=@&#39; $rc&quot;</span><span class="p">,</span> \
             <span class="p">{</span><span class="s1">&#39;lc&#39;</span><span class="p">:</span><span class="n">lc</span><span class="o">.</span><span class="n">copy_mod</span><span class="p">()</span><span class="o">.</span><span class="n">map_labels</span><span class="p">({</span><span class="s1">&#39;#&#39;</span><span class="p">:</span> <span class="s1">&#39;@#@&#39;</span><span class="p">}),</span>\
             <span class="s1">&#39;rc&#39;</span><span class="p">:</span><span class="n">rc</span><span class="o">.</span><span class="n">copy_mod</span><span class="p">()</span><span class="o">.</span><span class="n">map_labels</span><span class="p">({</span><span class="s1">&#39;#&#39;</span><span class="p">:</span> <span class="s1">&#39;@#@&#39;</span><span class="p">})})</span> <span class="k">for</span> <span class="n">lc</span><span class="p">,</span> <span class="n">rc</span> <span class="ow">in</span> <span class="n">contexts</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cs</span> <span class="o">=</span> <span class="p">(</span><span class="n">FST</span><span class="o">.</span><span class="n">re</span><span class="p">(</span><span class="s2">&quot;$lc &#39;@=@&#39; (.-&#39;@=@&#39;)* &#39;@=@&#39; $rc&quot;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;lc&#39;</span><span class="p">:</span><span class="n">lc</span><span class="p">,</span> <span class="s1">&#39;rc&#39;</span><span class="p">:</span><span class="n">rc</span><span class="p">})</span> <span class="k">for</span> <span class="n">lc</span><span class="p">,</span> <span class="n">rc</span> <span class="ow">in</span> <span class="n">contexts</span><span class="p">)</span>
    <span class="n">cunion</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">cs</span><span class="p">)</span><span class="o">.</span><span class="n">determinize</span><span class="p">()</span><span class="o">.</span><span class="n">minimize</span><span class="p">()</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">FST</span><span class="o">.</span><span class="n">re</span><span class="p">(</span><span class="s2">&quot;(.-&#39;@=@&#39;)* &#39;@=@&#39; $c &#39;@=@&#39; (.-&#39;@=@&#39;)* - ((.-&#39;@=@&#39;)* $cunion (.-&#39;@=@&#39;)*)&quot;</span><span class="p">,</span>\
                   <span class="p">{</span><span class="s1">&#39;c&#39;</span><span class="p">:</span><span class="n">fst</span><span class="p">,</span> <span class="s1">&#39;cunion&#39;</span><span class="p">:</span><span class="n">cunion</span><span class="p">})</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">map_labels</span><span class="p">({</span><span class="s1">&#39;@=@&#39;</span><span class="p">:</span><span class="s1">&#39;&#39;</span><span class="p">})</span><span class="o">.</span><span class="n">epsilon_remove</span><span class="p">()</span><span class="o">.</span><span class="n">determinize_as_dfa</span><span class="p">()</span><span class="o">.</span><span class="n">minimize</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">fsm</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">contexts</span><span class="p">):</span>
        <span class="n">fsm</span><span class="o">.</span><span class="n">alphabet</span> <span class="o">-=</span> <span class="p">{</span><span class="s1">&#39;@=@&#39;</span><span class="p">}</span> <span class="c1"># Remove aux syms from contexts</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">FST</span><span class="o">.</span><span class="n">re</span><span class="p">(</span><span class="s2">&quot;.? (.-&#39;@#@&#39;)* .? - $r&quot;</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;r&#39;</span><span class="p">:</span> <span class="n">r</span><span class="p">})</span>
    <span class="n">newfst</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">map_labels</span><span class="p">({</span><span class="s1">&#39;@#@&#39;</span><span class="p">:</span><span class="s1">&#39;&#39;</span><span class="p">})</span><span class="o">.</span><span class="n">epsilon_remove</span><span class="p">()</span><span class="o">.</span><span class="n">determinize_as_dfa</span><span class="p">()</span><span class="o">.</span><span class="n">minimize</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">newfst</span></div>



<div class="viewcode-block" id="projected">
<a class="viewcode-back" href="../../pyfoma.html#pyfoma.algorithms.projected">[docs]</a>
<span class="nd">@_copy_param</span>
<span class="k">def</span><span class="w"> </span><span class="nf">projected</span><span class="p">(</span><span class="n">fst</span><span class="p">:</span> <span class="s1">&#39;FST&#39;</span><span class="p">,</span> <span class="n">dim</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;FST&#39;</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns a modified FST, by projecting fst. dim = -1 will get output proj regardless of # of tapes.&quot;&quot;&quot;</span>
    <span class="n">sl</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">dim</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="k">else</span> <span class="nb">slice</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">dim</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">newalphabet</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">fst</span><span class="o">.</span><span class="n">states</span><span class="p">:</span>
        <span class="n">newtransitions</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">lbl</span><span class="p">,</span> <span class="n">tr</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">transitions</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">newtransitions</span><span class="p">[</span><span class="n">lbl</span><span class="p">[</span><span class="n">sl</span><span class="p">]]</span> <span class="o">=</span> <span class="n">newtransitions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">lbl</span><span class="p">[</span><span class="n">sl</span><span class="p">],</span> <span class="nb">set</span><span class="p">())</span> <span class="o">|</span> <span class="n">tr</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tr</span><span class="p">:</span>
                <span class="n">t</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">lbl</span><span class="p">[</span><span class="n">sl</span><span class="p">]</span>
                <span class="n">newalphabet</span> <span class="o">|=</span> <span class="p">{</span><span class="n">sublabel</span> <span class="k">for</span> <span class="n">sublabel</span> <span class="ow">in</span> <span class="n">lbl</span><span class="p">[</span><span class="n">sl</span><span class="p">]}</span>
        <span class="n">s</span><span class="o">.</span><span class="n">transitions</span> <span class="o">=</span> <span class="n">newtransitions</span>
    <span class="k">if</span> <span class="s1">&#39;.&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">newalphabet</span><span class="p">:</span> <span class="c1"># Preserve . semantics if it occurs on the tape we extract</span>
        <span class="n">fst</span><span class="o">.</span><span class="n">alphabet</span> <span class="o">=</span> <span class="n">newalphabet</span>
    <span class="k">return</span> <span class="n">fst</span></div>



<div class="viewcode-block" id="reversed">
<a class="viewcode-back" href="../../pyfoma.html#pyfoma.algorithms.reversed">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">reversed</span><span class="p">(</span><span class="n">fst</span><span class="p">:</span> <span class="s1">&#39;FST&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;FST&#39;</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns a modified FST, reversing the FST, epsilon-free.&quot;&quot;&quot;</span>
    <span class="n">newfst</span> <span class="o">=</span> <span class="n">FST</span><span class="p">(</span><span class="n">alphabet</span> <span class="o">=</span> <span class="n">fst</span><span class="o">.</span><span class="n">alphabet</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
    <span class="n">newfst</span><span class="o">.</span><span class="n">initialstate</span> <span class="o">=</span> <span class="n">State</span><span class="p">()</span>
    <span class="n">mapping</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="n">State</span><span class="p">()</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">fst</span><span class="o">.</span><span class="n">states</span><span class="p">}</span>
    <span class="n">newfst</span><span class="o">.</span><span class="n">states</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">mapping</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">|</span> <span class="p">{</span><span class="n">newfst</span><span class="o">.</span><span class="n">initialstate</span><span class="p">}</span>
    <span class="n">newfst</span><span class="o">.</span><span class="n">finalstates</span> <span class="o">=</span> <span class="p">{</span><span class="n">mapping</span><span class="p">[</span><span class="n">fst</span><span class="o">.</span><span class="n">initialstate</span><span class="p">]}</span>
    <span class="k">if</span> <span class="n">fst</span><span class="o">.</span><span class="n">initialstate</span> <span class="ow">in</span> <span class="n">fst</span><span class="o">.</span><span class="n">finalstates</span><span class="p">:</span>
        <span class="n">newfst</span><span class="o">.</span><span class="n">finalstates</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">newfst</span><span class="o">.</span><span class="n">initialstate</span><span class="p">)</span>
        <span class="n">newfst</span><span class="o">.</span><span class="n">initialstate</span><span class="o">.</span><span class="n">finalweight</span> <span class="o">=</span> <span class="n">fst</span><span class="o">.</span><span class="n">initialstate</span><span class="o">.</span><span class="n">finalweight</span>
    <span class="n">mapping</span><span class="p">[</span><span class="n">fst</span><span class="o">.</span><span class="n">initialstate</span><span class="p">]</span><span class="o">.</span><span class="n">finalweight</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">lbl</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">fst</span><span class="o">.</span><span class="n">all_transitions</span><span class="p">(</span><span class="n">fst</span><span class="o">.</span><span class="n">states</span><span class="p">):</span>
        <span class="n">mapping</span><span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">targetstate</span><span class="p">]</span><span class="o">.</span><span class="n">add_transition</span><span class="p">(</span><span class="n">mapping</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">lbl</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">weight</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">t</span><span class="o">.</span><span class="n">targetstate</span> <span class="ow">in</span> <span class="n">fst</span><span class="o">.</span><span class="n">finalstates</span><span class="p">:</span>
            <span class="n">newfst</span><span class="o">.</span><span class="n">initialstate</span><span class="o">.</span><span class="n">add_transition</span><span class="p">(</span><span class="n">mapping</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">lbl</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">weight</span> <span class="o">+</span> \
                                               <span class="n">t</span><span class="o">.</span><span class="n">targetstate</span><span class="o">.</span><span class="n">finalweight</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">newfst</span></div>



<div class="viewcode-block" id="reversed_e">
<a class="viewcode-back" href="../../pyfoma.html#pyfoma.algorithms.reversed_e">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">reversed_e</span><span class="p">(</span><span class="n">fst</span><span class="p">:</span> <span class="s1">&#39;FST&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;FST&#39;</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns a modified FST, reversing the FST, using epsilons.&quot;&quot;&quot;</span>
    <span class="n">newfst</span> <span class="o">=</span> <span class="n">FST</span><span class="p">(</span><span class="n">alphabet</span> <span class="o">=</span> <span class="n">fst</span><span class="o">.</span><span class="n">alphabet</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
    <span class="n">newfst</span><span class="o">.</span><span class="n">initialstate</span> <span class="o">=</span> <span class="n">State</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">fst</span><span class="o">.</span><span class="n">finalstates</span><span class="p">))</span>
    <span class="n">mapping</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="n">State</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="n">k</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">fst</span><span class="o">.</span><span class="n">states</span><span class="p">}</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">fst</span><span class="o">.</span><span class="n">finalstates</span><span class="p">:</span>
        <span class="n">newfst</span><span class="o">.</span><span class="n">initialstate</span><span class="o">.</span><span class="n">add_transition</span><span class="p">(</span><span class="n">mapping</span><span class="p">[</span><span class="n">t</span><span class="p">],</span> <span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,),</span> <span class="n">t</span><span class="o">.</span><span class="n">finalweight</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">lbl</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">fst</span><span class="o">.</span><span class="n">all_transitions</span><span class="p">(</span><span class="n">fst</span><span class="o">.</span><span class="n">states</span><span class="p">):</span>
        <span class="n">mapping</span><span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">targetstate</span><span class="p">]</span><span class="o">.</span><span class="n">add_transition</span><span class="p">(</span><span class="n">mapping</span><span class="p">[</span><span class="n">s</span><span class="p">],</span> <span class="n">lbl</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">weight</span><span class="p">)</span>

    <span class="n">newfst</span><span class="o">.</span><span class="n">states</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">mapping</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">|</span> <span class="p">{</span><span class="n">newfst</span><span class="o">.</span><span class="n">initialstate</span><span class="p">}</span>
    <span class="n">newfst</span><span class="o">.</span><span class="n">finalstates</span> <span class="o">=</span> <span class="p">{</span><span class="n">mapping</span><span class="p">[</span><span class="n">fst</span><span class="o">.</span><span class="n">initialstate</span><span class="p">]}</span>
    <span class="n">mapping</span><span class="p">[</span><span class="n">fst</span><span class="o">.</span><span class="n">initialstate</span><span class="p">]</span><span class="o">.</span><span class="n">finalweight</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">return</span> <span class="n">newfst</span></div>



<div class="viewcode-block" id="union">
<a class="viewcode-back" href="../../pyfoma.html#pyfoma.algorithms.union">[docs]</a>
<span class="nd">@_harmonize_alphabet</span>
<span class="k">def</span><span class="w"> </span><span class="nf">union</span><span class="p">(</span><span class="n">fst1</span><span class="p">:</span> <span class="s1">&#39;FST&#39;</span><span class="p">,</span> <span class="n">fst2</span><span class="p">:</span> <span class="s1">&#39;FST&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;FST&#39;</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Epsilon-free calculation of union of fst1 and fst2.&quot;&quot;&quot;</span>
    <span class="n">mapping</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="n">State</span><span class="p">()</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">fst1</span><span class="o">.</span><span class="n">states</span> <span class="o">|</span> <span class="n">fst2</span><span class="o">.</span><span class="n">states</span><span class="p">}</span>
    <span class="n">newfst</span> <span class="o">=</span> <span class="n">FST</span><span class="p">()</span> <span class="c1"># Get new initial state</span>
    <span class="n">newfst</span><span class="o">.</span><span class="n">states</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">mapping</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">|</span> <span class="p">{</span><span class="n">newfst</span><span class="o">.</span><span class="n">initialstate</span><span class="p">}</span>
    <span class="c1"># Copy all transitions from old initial states to new initial state</span>
    <span class="k">for</span> <span class="n">lbl</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="n">fst1</span><span class="o">.</span><span class="n">initialstate</span><span class="o">.</span><span class="n">all_transitions</span><span class="p">(),</span> <span class="n">fst2</span><span class="o">.</span><span class="n">initialstate</span><span class="o">.</span><span class="n">all_transitions</span><span class="p">()):</span>
        <span class="n">newfst</span><span class="o">.</span><span class="n">initialstate</span><span class="o">.</span><span class="n">add_transition</span><span class="p">(</span><span class="n">mapping</span><span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">targetstate</span><span class="p">],</span> <span class="n">lbl</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">weight</span><span class="p">)</span>
    <span class="c1"># Also add all transitions from old FSMs to new FSM</span>
    <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">lbl</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="n">fst1</span><span class="o">.</span><span class="n">all_transitions</span><span class="p">(</span><span class="n">fst1</span><span class="o">.</span><span class="n">states</span><span class="p">),</span> <span class="n">fst2</span><span class="o">.</span><span class="n">all_transitions</span><span class="p">(</span><span class="n">fst2</span><span class="o">.</span><span class="n">states</span><span class="p">)):</span>
        <span class="n">mapping</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">add_transition</span><span class="p">(</span><span class="n">mapping</span><span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">targetstate</span><span class="p">],</span> <span class="n">lbl</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">weight</span><span class="p">)</span>
    <span class="c1"># Make old final states final in new FSM</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">fst1</span><span class="o">.</span><span class="n">finalstates</span> <span class="o">|</span> <span class="n">fst2</span><span class="o">.</span><span class="n">finalstates</span><span class="p">:</span>
        <span class="n">newfst</span><span class="o">.</span><span class="n">finalstates</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">mapping</span><span class="p">[</span><span class="n">s</span><span class="p">])</span>
        <span class="n">mapping</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">finalweight</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">finalweight</span>
    <span class="c1"># If either initial state was final, make new initial final w/ weight min(f1w, f2w)</span>
    <span class="n">newfst</span><span class="o">.</span><span class="n">finalstates</span> <span class="o">=</span> <span class="p">{</span><span class="n">mapping</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">fst1</span><span class="o">.</span><span class="n">finalstates</span><span class="o">|</span><span class="n">fst2</span><span class="o">.</span><span class="n">finalstates</span><span class="p">}</span>
    <span class="k">if</span> <span class="n">fst1</span><span class="o">.</span><span class="n">initialstate</span> <span class="ow">in</span> <span class="n">fst1</span><span class="o">.</span><span class="n">finalstates</span> <span class="ow">or</span> <span class="n">fst2</span><span class="o">.</span><span class="n">initialstate</span> <span class="ow">in</span> <span class="n">fst2</span><span class="o">.</span><span class="n">finalstates</span><span class="p">:</span>
        <span class="n">newfst</span><span class="o">.</span><span class="n">finalstates</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">newfst</span><span class="o">.</span><span class="n">initialstate</span><span class="p">)</span>
        <span class="n">newfst</span><span class="o">.</span><span class="n">initialstate</span><span class="o">.</span><span class="n">finalweight</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">fst1</span><span class="o">.</span><span class="n">initialstate</span><span class="o">.</span><span class="n">finalweight</span><span class="p">,</span> <span class="n">fst2</span><span class="o">.</span><span class="n">initialstate</span><span class="o">.</span><span class="n">finalweight</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">newfst</span></div>



<div class="viewcode-block" id="intersection">
<a class="viewcode-back" href="../../pyfoma.html#pyfoma.algorithms.intersection">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">intersection</span><span class="p">(</span><span class="n">fst1</span><span class="p">:</span> <span class="s1">&#39;FST&#39;</span><span class="p">,</span> <span class="n">fst2</span><span class="p">:</span> <span class="s1">&#39;FST&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;FST&#39;</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Intersection of self and other. Uses the product algorithm.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">product</span><span class="p">(</span><span class="n">fst1</span><span class="p">,</span> <span class="n">fst2</span><span class="p">,</span> <span class="n">finalf</span> <span class="o">=</span> <span class="nb">all</span><span class="p">,</span> <span class="n">oplus</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">add</span><span class="p">,</span> <span class="n">pathfollow</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="n">y</span><span class="p">)</span></div>



<div class="viewcode-block" id="difference">
<a class="viewcode-back" href="../../pyfoma.html#pyfoma.algorithms.difference">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">difference</span><span class="p">(</span><span class="n">fst1</span><span class="p">:</span> <span class="s1">&#39;FST&#39;</span><span class="p">,</span> <span class="n">fst2</span><span class="p">:</span> <span class="s1">&#39;FST&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;FST&#39;</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns self-other. Uses the product algorithm.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">product</span><span class="p">(</span><span class="n">fst1</span><span class="p">,</span> <span class="n">fst2</span><span class="p">,</span> <span class="n">finalf</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>\
                       <span class="n">oplus</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span> <span class="n">pathfollow</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="n">x</span><span class="p">)</span></div>



<div class="viewcode-block" id="complement">
<a class="viewcode-back" href="../../pyfoma.html#pyfoma.algorithms.complement">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">complement</span><span class="p">(</span><span class="n">fst</span><span class="p">:</span> <span class="s1">&#39;FST&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;FST&#39;</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns the complement of an FST.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">FST</span><span class="o">.</span><span class="n">re</span><span class="p">(</span><span class="s2">&quot;.* - $X&quot;</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;X&quot;</span><span class="p">:</span> <span class="n">fst</span><span class="p">})</span></div>



<div class="viewcode-block" id="product">
<a class="viewcode-back" href="../../pyfoma.html#pyfoma.algorithms.product">[docs]</a>
<span class="nd">@_harmonize_alphabet</span>
<span class="k">def</span><span class="w"> </span><span class="nf">product</span><span class="p">(</span><span class="n">fst1</span><span class="p">:</span> <span class="s1">&#39;FST&#39;</span><span class="p">,</span> <span class="n">fst2</span><span class="p">:</span> <span class="s1">&#39;FST&#39;</span><span class="p">,</span> <span class="n">finalf</span> <span class="o">=</span> <span class="nb">any</span><span class="p">,</span> <span class="n">oplus</span> <span class="o">=</span> <span class="nb">min</span><span class="p">,</span> <span class="n">pathfollow</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="n">x</span><span class="o">|</span><span class="n">y</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;FST&#39;</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generates the product FST from fst1, fst2. The helper functions by default</span>
<span class="sd">       produce fst1|fst2.&quot;&quot;&quot;</span>
    <span class="n">newfst</span> <span class="o">=</span> <span class="n">FST</span><span class="p">()</span>
    <span class="n">Q</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([(</span><span class="n">fst1</span><span class="o">.</span><span class="n">initialstate</span><span class="p">,</span> <span class="n">fst2</span><span class="o">.</span><span class="n">initialstate</span><span class="p">)])</span>
    <span class="n">S</span> <span class="o">=</span> <span class="p">{(</span><span class="n">fst1</span><span class="o">.</span><span class="n">initialstate</span><span class="p">,</span> <span class="n">fst2</span><span class="o">.</span><span class="n">initialstate</span><span class="p">):</span> <span class="n">newfst</span><span class="o">.</span><span class="n">initialstate</span><span class="p">}</span>
    <span class="n">dead1</span><span class="p">,</span> <span class="n">dead2</span> <span class="o">=</span> <span class="n">State</span><span class="p">(</span><span class="n">finalweight</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)),</span> <span class="n">State</span><span class="p">(</span><span class="n">finalweight</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">))</span>
    <span class="k">while</span> <span class="n">Q</span><span class="p">:</span>
        <span class="n">t1s</span><span class="p">,</span> <span class="n">t2s</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">currentstate</span> <span class="o">=</span> <span class="n">S</span><span class="p">[(</span><span class="n">t1s</span><span class="p">,</span> <span class="n">t2s</span><span class="p">)]</span>
        <span class="n">currentstate</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="p">(</span><span class="n">t1s</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">t2s</span><span class="o">.</span><span class="n">name</span><span class="p">,)</span>
        <span class="k">if</span> <span class="n">finalf</span><span class="p">((</span><span class="n">t1s</span> <span class="ow">in</span> <span class="n">fst1</span><span class="o">.</span><span class="n">finalstates</span><span class="p">,</span> <span class="n">t2s</span> <span class="ow">in</span> <span class="n">fst2</span><span class="o">.</span><span class="n">finalstates</span><span class="p">)):</span>
            <span class="n">newfst</span><span class="o">.</span><span class="n">finalstates</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">currentstate</span><span class="p">)</span>
            <span class="n">currentstate</span><span class="o">.</span><span class="n">finalweight</span> <span class="o">=</span> <span class="n">oplus</span><span class="p">(</span><span class="n">t1s</span><span class="o">.</span><span class="n">finalweight</span><span class="p">,</span> <span class="n">t2s</span><span class="o">.</span><span class="n">finalweight</span><span class="p">)</span>
        <span class="c1"># Get all outgoing labels we want to follow</span>
        <span class="k">for</span> <span class="n">lbl</span> <span class="ow">in</span> <span class="n">pathfollow</span><span class="p">(</span><span class="n">t1s</span><span class="o">.</span><span class="n">transitions</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">t2s</span><span class="o">.</span><span class="n">transitions</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="k">for</span> <span class="n">outtr</span> <span class="ow">in</span> <span class="n">t1s</span><span class="o">.</span><span class="n">transitions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">lbl</span><span class="p">,</span> <span class="p">(</span><span class="n">Transition</span><span class="p">(</span><span class="n">dead1</span><span class="p">,</span> <span class="n">lbl</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)),</span> <span class="p">)):</span>
                <span class="k">for</span> <span class="n">intr</span> <span class="ow">in</span> <span class="n">t2s</span><span class="o">.</span><span class="n">transitions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">lbl</span><span class="p">,</span> <span class="p">(</span><span class="n">Transition</span><span class="p">(</span><span class="n">dead2</span><span class="p">,</span> <span class="n">lbl</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)),</span> <span class="p">)):</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">outtr</span><span class="o">.</span><span class="n">targetstate</span><span class="p">,</span> <span class="n">intr</span><span class="o">.</span><span class="n">targetstate</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">S</span><span class="p">:</span>
                        <span class="n">Q</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">outtr</span><span class="o">.</span><span class="n">targetstate</span><span class="p">,</span> <span class="n">intr</span><span class="o">.</span><span class="n">targetstate</span><span class="p">))</span>
                        <span class="n">S</span><span class="p">[(</span><span class="n">outtr</span><span class="o">.</span><span class="n">targetstate</span><span class="p">,</span> <span class="n">intr</span><span class="o">.</span><span class="n">targetstate</span><span class="p">)]</span> <span class="o">=</span> <span class="n">State</span><span class="p">()</span>
                        <span class="n">newfst</span><span class="o">.</span><span class="n">states</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">S</span><span class="p">[(</span><span class="n">outtr</span><span class="o">.</span><span class="n">targetstate</span><span class="p">,</span> <span class="n">intr</span><span class="o">.</span><span class="n">targetstate</span><span class="p">)])</span>
                    <span class="n">currentstate</span><span class="o">.</span><span class="n">add_transition</span><span class="p">(</span><span class="n">S</span><span class="p">[(</span><span class="n">outtr</span><span class="o">.</span><span class="n">targetstate</span><span class="p">,</span> <span class="n">intr</span><span class="o">.</span><span class="n">targetstate</span><span class="p">)],</span> <span class="n">lbl</span><span class="p">,</span> <span class="n">oplus</span><span class="p">(</span><span class="n">outtr</span><span class="o">.</span><span class="n">weight</span><span class="p">,</span> <span class="n">intr</span><span class="o">.</span><span class="n">weight</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">newfst</span></div>

<span class="c1"># endregion</span>


<span class="c1"># Defines a list of functions that should be added as instance methods to the FST class dynamically</span>
<span class="n">_algorithms_to_add</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Callable</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;trim&#39;</span><span class="p">:</span> <span class="n">trimmed</span><span class="p">,</span>
    <span class="s1">&#39;filter_accessible&#39;</span><span class="p">:</span> <span class="n">filtered_accessible</span><span class="p">,</span>
    <span class="s1">&#39;filter_coaccessible&#39;</span><span class="p">:</span> <span class="n">filtered_coaccessible</span><span class="p">,</span>
    <span class="s1">&#39;scc&#39;</span><span class="p">:</span> <span class="n">scc</span><span class="p">,</span>
    <span class="s1">&#39;push_weights&#39;</span><span class="p">:</span> <span class="n">pushed_weights</span><span class="p">,</span>
    <span class="s1">&#39;map_labels&#39;</span><span class="p">:</span> <span class="n">mapped_labels</span><span class="p">,</span>
    <span class="s1">&#39;epsilon_remove&#39;</span><span class="p">:</span> <span class="n">epsilon_removed</span><span class="p">,</span>
    <span class="s1">&#39;epsilon_closure&#39;</span><span class="p">:</span> <span class="n">epsilon_closure</span><span class="p">,</span>
    <span class="s1">&#39;dijkstra&#39;</span><span class="p">:</span> <span class="n">dijkstra</span><span class="p">,</span>
    <span class="s1">&#39;label_states_topology&#39;</span><span class="p">:</span> <span class="n">labelled_states_topology</span><span class="p">,</span>
    <span class="s1">&#39;words_nbest&#39;</span><span class="p">:</span> <span class="n">words_nbest</span><span class="p">,</span>
    <span class="s1">&#39;words_cheapest&#39;</span><span class="p">:</span> <span class="n">words_cheapest</span><span class="p">,</span>
    <span class="s1">&#39;determinize_unweighted&#39;</span><span class="p">:</span> <span class="n">determinized_unweighted</span><span class="p">,</span>
    <span class="s1">&#39;determinize_as_dfa&#39;</span><span class="p">:</span> <span class="n">determinized_as_dfa</span><span class="p">,</span>
    <span class="s1">&#39;determinize&#39;</span><span class="p">:</span> <span class="n">determinized</span><span class="p">,</span>
    <span class="s1">&#39;minimize_as_dfa&#39;</span><span class="p">:</span> <span class="n">minimized_as_dfa</span><span class="p">,</span>
    <span class="s1">&#39;minimize&#39;</span><span class="p">:</span> <span class="n">minimized</span><span class="p">,</span>
    <span class="s1">&#39;merge_equivalent_states&#39;</span><span class="p">:</span> <span class="n">merging_equivalent_states</span><span class="p">,</span>
    <span class="s1">&#39;find_sourcestates&#39;</span><span class="p">:</span> <span class="n">find_sourcestates</span><span class="p">,</span>
    <span class="s1">&#39;create_reverse_index&#39;</span><span class="p">:</span> <span class="n">create_reverse_index</span><span class="p">,</span>
    <span class="s1">&#39;minimize_brz&#39;</span><span class="p">:</span> <span class="n">minimized_brz</span><span class="p">,</span>
    <span class="s1">&#39;kleene_closure&#39;</span><span class="p">:</span> <span class="n">kleene_closure</span><span class="p">,</span>
    <span class="s1">&#39;eliminate_flags&#39;</span><span class="p">:</span> <span class="n">eliminate_flags</span><span class="p">,</span>
    <span class="s1">&#39;add_weight&#39;</span><span class="p">:</span> <span class="n">added_weight</span><span class="p">,</span>
    <span class="s1">&#39;optional&#39;</span><span class="p">:</span> <span class="n">optional</span><span class="p">,</span>
    <span class="s1">&#39;concatenate&#39;</span><span class="p">:</span> <span class="n">concatenate</span><span class="p">,</span>
    <span class="s1">&#39;cross_product&#39;</span><span class="p">:</span> <span class="n">cross_product</span><span class="p">,</span>
    <span class="s1">&#39;compose&#39;</span><span class="p">:</span> <span class="n">compose</span><span class="p">,</span>
    <span class="s1">&#39;invert&#39;</span><span class="p">:</span> <span class="n">inverted</span><span class="p">,</span>
    <span class="s1">&#39;ignore&#39;</span><span class="p">:</span> <span class="n">ignore</span><span class="p">,</span>
    <span class="s1">&#39;rewrite&#39;</span><span class="p">:</span> <span class="n">rewritten</span><span class="p">,</span>
    <span class="s1">&#39;context_restrict&#39;</span><span class="p">:</span> <span class="n">context_restricted</span><span class="p">,</span>
    <span class="s1">&#39;project&#39;</span><span class="p">:</span> <span class="n">projected</span><span class="p">,</span>
    <span class="s1">&#39;reverse&#39;</span><span class="p">:</span> <span class="nb">reversed</span><span class="p">,</span>
    <span class="s1">&#39;reverse_e&#39;</span><span class="p">:</span> <span class="n">reversed_e</span><span class="p">,</span>
    <span class="s1">&#39;union&#39;</span><span class="p">:</span> <span class="n">union</span><span class="p">,</span>
    <span class="s1">&#39;intersection&#39;</span><span class="p">:</span> <span class="n">intersection</span><span class="p">,</span>
    <span class="s1">&#39;difference&#39;</span><span class="p">:</span> <span class="n">difference</span><span class="p">,</span>
    <span class="s1">&#39;product&#39;</span><span class="p">:</span> <span class="n">product</span><span class="p">,</span>
    <span class="s1">&#39;complement&#39;</span><span class="p">:</span> <span class="n">complement</span><span class="p">,</span>
<span class="p">}</span>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">PyFoma</a></h1>









<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2025, Mans Hulden and Michael Ginn.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.2.1</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
    </div>

    

    
  </body>
</html>